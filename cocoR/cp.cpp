//****************************************************************
//   CPLUS2\PARSER_C.FRM
//   Coco/R C++ Support Frames.
//   Author: Frankie Arzu <farzu@uvg.edu.gt>
//
//   Jun 12, 1996  Version 1.06
//      Many fixes and suggestions thanks to
//      Pat Terry <p.terry@.ru.ac.za>
//   Oct 11, 1997  Version 1.07
//      Eliminated redundant ";" in some places
//****************************************************************

/*************** NOTICE ****************
	This file is generated by cocoR       
***************************************/

#include "clib.h"
#include "cc.hpp"

# line 9 "cs.atg"
/////////////////////////////////
// add by jackie juju
#include "clib.h"
#include <string.h>
#include <vector>
#include <string>
#include "datatype.h"
#include "LoopTree.h"
#include "opcode.h"
#include "os/CSS_LOCKEX.h"
#include "ScriptFuncTable.h"
#include "log.h"
#include "PubFuncTable.h"
#include "ClassDes.h"
#include "compiler.h"
#include "utility.h"

#define CAST Cast(op1, type1, dt1, op2, type2, dt2);


// add by jackie juju
/////////////////////////////////



#include "cp.hpp"
#include "cs.hpp"

unsigned short int cParser::SymSet[][MAXSYM] = {
  /*EOF_Sym */
  {0x1,0x0,0x0,0x0,0x0,0x0},
  
  {0x0}
};
BOOL cParser::init(CClassDesTable *table, CPubFuncTable* pft, CConfigure* c){
	m_classTable = table;
	m_PubFuncTable = pft;
	m_conf = c;
	// show options
	showOptions();
	return TRUE;
}

void cParser::destroy(){

}
void cParser::Get()
{ do {
    Sym = Scanner->Get();//aa
    Scanner->NextSym.SetSym(Sym);
    if (Sym <= MAXT) Error->ErrorDist ++;
    else {
      if (Sym == PreProcessorSym) { /*83*/
      # line 60 "cs.atg"
	
      	    // process #include                                 
      	char str[256];
      	Scanner->GetName(&Scanner->NextSym, str, 255);
      	// get directive
      	char* p = strchr(str, ' ');
      	char* directive = NULL;
      	char* content = NULL;
      	if ( p != NULL ){
      	    *p=0; 
      	    directive = str + sizeof(char);
      	    // proce include 
      	    if (strcmp(str, "include") == 0){
      	            // get content
      	            p += sizeof(char);
      	            while ( (*p == ' ' || *p == '\t' ) && *p != '\0' ){
      	                    p += sizeof(char);              
      	            }
      	            if ( *p != '\0' )
      	                    content = p;
      	    }
      	
      	}
      	    
      	    ;
      } else
      /* Empty Stmt */ ;
      Scanner->NextSym = Scanner->CurrSym;
    }
  } while (Sym > MAXT);
}

void cParser::ExpectWeak(int n, int follow)
{ if (Sym == n) Get();
  else {
    GENERR(n);
    while (!(In(SymSet[follow], Sym) || In(SymSet[0], Sym))) Get();
  }
}

int cParser::WeakSeparator(int n, int syFol, int repFol)
{ unsigned short int s[MAXSYM];
  int i;

  if (Sym == n) { Get(); return 1; }
  if (In(SymSet[repFol], Sym)) return 0;

  for (i = 0; i < MAXSYM; i++)
    s[i] = SymSet[0][i] | SymSet[syFol][i] | SymSet[repFol][i];
  GENERR(n);
  while (!In(s, Sym)) Get();
  return In(SymSet[syFol], Sym);
}

# line 92 "cs.atg"
void cParser::C()
{
# line 92 "cs.atg"
	
	
	m_pCurClassDes = new CClassDes(this);
	std::string className = JUJU::getFileName(curFileName);
	m_pCurClassDes->SetName((char*)className.c_str());     
	
	// add class def first because it maybe referenced by its own code
	m_classTable->addClass(m_pCurClassDes);
	
# line 102 "cs.atg"
	while (Sym == useSym ||
	       Sym == loadSym) {
# line 102 "cs.atg"
		if (Sym == useSym) {
# line 102 "cs.atg"
			Import();
		} else if (Sym == loadSym) {
# line 102 "cs.atg"
			LoadLib();
		} else GenError(84);
	}
# line 102 "cs.atg"
	if (Sym == inheritSym) {
# line 102 "cs.atg"
		Inheritance();
	}
# line 104 "cs.atg"
	while (Sym == identifierSym ||
	       Sym == classSym ||
	       Sym >= staticSym && Sym <= stringSym) {
# line 104 "cs.atg"
		Definition();
	}
# line 104 "cs.atg"
	Expect(EOF_Sym);
# line 104 "cs.atg"
	
	
	if (Error->Errors){ // if compile failed, remove this class
	m_classTable->removeClass((char*)className.c_str());
	}
	//      std::string name = m_pCurClassDes->GetFullName();
	//    name += ".class";
	//FILE* file = fopen(name.c_str(), "w");
	//std::string *s = m_pCurClassDes->output();
	//fprintf(file, "%s", s->c_str());
	//SAFEDELETE(s);
	//fclose(file);
	
}

# line 119 "cs.atg"
void cParser::Import()
{
# line 119 "cs.atg"
	Expect(useSym);
# line 119 "cs.atg"
	char szName[_MAX_PATH]= "";
# line 119 "cs.atg"
	ClassFullName(szName);
# line 120 "cs.atg"
	
	    // load class by name, if not found, look for the source and compile it
	    CClassDes* cd = this->m_classTable->getClass(szName);
	    if (cd == NULL){
	            strcat(szName, SCRIPT_EXT);
	                                            CCompiler cc;
	                             std::string s = JUJU::getFilePath(c->getCurSrcFile())+szName;
	                                    printf("current file: %s\n", c->getCurSrcFile());
	                                    printf("crrent file path: %s\n", JUJU::getFilePath(c->getCurSrcFile()).c_str());
	                                    printf("use %s\n", szName);
	                                                            if (m_conf)     
	                                                                    cc.setConf(*m_conf);
	                                                            
	                                                            cc.getClassPath().insert(cc.getClassPath().begin(), JUJU::getFilePath(c->getCurSrcFile()));
	                                cc.Compile(szName);
	    };
# line 136 "cs.atg"
	Expect(SemicolonSym);
}

# line 138 "cs.atg"
void cParser::LoadLib()
{
# line 138 "cs.atg"
	Expect(loadSym);
# line 138 "cs.atg"
	Expect(identifierSym);
# line 139 "cs.atg"
	
	        // load external library 
	        std::string lib = GetCurrSym();
	    #ifdef          WIN32
	        std::string libfile = lib+".dll";
	    #else
	            std::string libfile = "lib"+lib+".so";
	    #endif
	        std::string libintfile = lib+".int";
	    
	    int r=-1;
	#ifdef WIN32
	            r = m_PubFuncTable->LoadLib((char*)libfile.c_str(), (char*)libintfile.c_str());
	#else
	        char* c1 = (char*)(libfile).c_str();
	        char* c2 = (char*)(libintfile).c_str();
	            r = m_PubFuncTable->LoadLib(c1, c2);
	#endif
	            if (r){
	                    GENERR(128);
	            }
	/* for the further if VM run in another process than compiler run
	    int address = m_pMainFunction->AddStaticData(lib.size()+1, (BYTE*)lib.c_str());
	    ADDCOMMAND1(__loadlib, DS, address);
	*/              ;
# line 165 "cs.atg"
	Expect(SemicolonSym);
}

# line 217 "cs.atg"
void cParser::Inheritance()
{
# line 217 "cs.atg"
	Expect(inheritSym);
# line 217 "cs.atg"
	Expect(identifierSym);
# line 218 "cs.atg"
	
	
	// TODO get full name in current imported classes, should not need to provide full name here
	    char* szName = GetCurrSym();
	    CClassDes* cd = this->m_classTable->getClass(szName);
	    if (cd == NULL){
	            std::string s = JUJU::getFilePath(c->getCurSrcFile())+szName;
	            strcpy(szName, s.c_str());
	            cd = this->m_classTable->getClass(szName);
	            if (cd == NULL){
	                            strcat(szName, SCRIPT_EXT);
	                            CCompiler cc;                         
	                cc.Compile(szName);
	        }
	    }
	    this->m_pCurClassDes->setParent(szName);
# line 234 "cs.atg"
	Expect(SemicolonSym);
}

# line 170 "cs.atg"
void cParser::Definition()
{
# line 209 "cs.atg"
	if (Sym == identifierSym ||
	    Sym >= staticSym && Sym <= stringSym) {
# line 172 "cs.atg"
		if (Sym >= staticSym && Sym <= functionSym) {
# line 172 "cs.atg"
			StorageClass();
		}
# line 172 "cs.atg"
		PTYPEDES type = new TYPEDES;
# line 173 "cs.atg"
		if (Sym >= varSym && Sym <= stringSym) {
# line 173 "cs.atg"
			Type(type);
		}
# line 190 "cs.atg"
		Expect(identifierSym);
# line 191 "cs.atg"
		
		      char szName[MAX_IDENTIFIER_LENGTH];
		      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
		      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称;
# line 201 "cs.atg"
		if (Sym == LparenSym) {
# line 198 "cs.atg"
			FunctionDefinition();
# line 198 "cs.atg"
			this->m_pCurClassDes->AddMember(szName, *type);
		} else if (Sym == SemicolonSym ||
		           Sym == EqualSym) {
# line 204 "cs.atg"
			if (Sym == EqualSym) {
# line 203 "cs.atg"
				Get();
# line 203 "cs.atg"
				this->m_pCurClassDes->AddMember(szName, *type);
# line 203 "cs.atg"
				Expression();
# line 203 "cs.atg"
				/*TODO*/;
# line 203 "cs.atg"
				Expect(SemicolonSym);
			} else if (Sym == SemicolonSym) {
# line 204 "cs.atg"
				Get();
# line 204 "cs.atg"
				this->m_pCurClassDes->AddMember(szName, *type);
			} else GenError(85);
		} else GenError(86);
	} else if (Sym == classSym) {
# line 209 "cs.atg"
		ClassDef();
	} else GenError(87);
}

# line 1789 "cs.atg"
void cParser::ClassFullName(char* szName)
{
# line 1790 "cs.atg"
	Expect(identifierSym);
# line 1790 "cs.atg"
	strcpy(szName, GetCurrSym());
# line 1791 "cs.atg"
	while (Sym == ColonColonSym) {
# line 1791 "cs.atg"
		Get();
# line 1791 "cs.atg"
		strcat(szName, PATH_SEPARATOR_S);
# line 1792 "cs.atg"
		Expect(identifierSym);
# line 1792 "cs.atg"
		strcat(szName, GetCurrSym());
	}
}

# line 300 "cs.atg"
void cParser::StorageClass()
{
# line 302 "cs.atg"
	if (Sym == staticSym) {
# line 301 "cs.atg"
		Get();
	} else if (Sym == mySym) {
# line 302 "cs.atg"
		Get();
	} else if (Sym == functionSym) {
# line 303 "cs.atg"
		Get();
	} else GenError(88);
}

# line 306 "cs.atg"
void cParser::Type(PTYPEDES type)
{
# line 329 "cs.atg"
	switch (Sym) {
		case varSym: 
		case mixedSym:  
# line 312 "cs.atg"
			if (Sym == varSym) {
# line 312 "cs.atg"
				Get();
			} else if (Sym == mixedSym) {
# line 312 "cs.atg"
				Get();
			} else GenError(89);
# line 313 "cs.atg"
			
			              /*      #ifdef __SUPPORT_OBJ
			                      char szName[MAX_IDENTIFIER_LENGTH];
			                      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
			                      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称                     
			                      type->type = dtGeneral;
			                      type->objID = GetObjIDByName(szName); 
			                      if (type->objID == 0)
			                              GENERR(120);
			                      #else
			                      // TODO
			                              GENERR(120);
			                      #endif
			*/
			      type->type = dtGeneral; type->refLevel = 0;
			break;
		case shortSym:  
# line 330 "cs.atg"
			Get();
# line 330 "cs.atg"
			if (Sym == intSym) {
# line 330 "cs.atg"
				Get();
			}
# line 331 "cs.atg"
			                         type->type = dtShort; type->refLevel = 0;      
			break;
		case longSym:  
# line 332 "cs.atg"
			Get();
# line 332 "cs.atg"
			if (Sym == intSym ||
			    Sym == floatSym) {
# line 332 "cs.atg"
				if (Sym == intSym) {
# line 332 "cs.atg"
					Get();
				} else if (Sym == floatSym) {
# line 332 "cs.atg"
					Get();
				} else GenError(90);
			}
# line 333 "cs.atg"
			                         type->type = dtLong; type->refLevel = 0;
			break;
		case unsignedSym:  
# line 334 "cs.atg"
			Get();
# line 334 "cs.atg"
			if (Sym >= intSym && Sym <= longSym ||
			    Sym == charSym) {
# line 334 "cs.atg"
				if (Sym == charSym) {
# line 334 "cs.atg"
					Get();
				} else if (Sym == intSym) {
# line 334 "cs.atg"
					Get();
				} else if (Sym == longSym) {
# line 334 "cs.atg"
					Get();
				} else GenError(91);
			}
			break;
		case charSym:  
# line 335 "cs.atg"
			Get();
# line 336 "cs.atg"
			                        type->type = dtChar;                    type->refLevel = 0;
			break;
		case intSym:  
# line 337 "cs.atg"
			Get();
# line 338 "cs.atg"
			                         type->type = dtInt; type->refLevel = 0;
			break;
		case floatSym:  
# line 339 "cs.atg"
			Get();
# line 340 "cs.atg"
			                        type->type = dtFloat;                   type->refLevel = 0;
			break;
		case doubleSym:  
# line 342 "cs.atg"
			Get();
			break;
		case voidSym:  
# line 342 "cs.atg"
			Get();
			break;
		case stringSym:  
# line 342 "cs.atg"
			Get();
# line 343 "cs.atg"
			type->type =  dtStr;            type->refLevel = 0;
			break;
		default :GenError(92); break;
	}
}

# line 371 "cs.atg"
void cParser::FunctionDefinition()
{
# line 372 "cs.atg"
	
	    this->m_pMainFunction = new CFunction;
	    printf("--->m_pMainFunction1=%x", m_pMainFunction);
	
	    //for test
	    long t = sizeof(CFunction);
	    m_pMainFunction->m_SymbolTable.m_pParser = this;
	    this->m_LoopTree->m_pFunc = m_pMainFunction;
	    
	    char szName[MAX_IDENTIFIER_LENGTH];
	    memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	    Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
	
	    if (strlen(szName) > 20)
	            GENERR(105);
	    else
	            strcpy(m_pMainFunction->m_szName, szName);
	            
	    // add "this" as first parameter to function if it belong to a class
	    if (m_pCurClassDes){
	            PTYPEDES type = new TYPEDES;
	            type->refLevel = 1;
	            type->type = dtObject;
	            if (!AllocVar(type, "this"))
	                    GENERR(113);
	            else
	                    m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
	            delete type;
	    }
	    
	            ;
# line 404 "cs.atg"
	FunctionHeader();
# line 404 "cs.atg"
	FunctionBody();
# line 405 "cs.atg"
	
	    if (!this->Error->Errors)
	    {
	               char path[_MAX_PATH];
	                            if (strlen(m_szByteCodeFilePath) == 0 )
	                                    sprintf(path, "%s.%s", this->m_pCurClassDes->GetFullName(),szName);
	                            else
	                                    sprintf(path, "%s%s%s.%s", m_szByteCodeFilePath, PATH_SEPARATOR_S, this->m_pCurClassDes->GetFullName(),szName);
	                m_pMainFunction->Output(path);
	            
	    }else{
	    printf("--->m_pMainFunction2=%x", m_pMainFunction);
	            SAFEDELETE( m_pMainFunction);   
	     }
	     m_pMainFunction = NULL;
}

# line 827 "cs.atg"
void cParser::Expression()
{
# line 827 "cs.atg"
	Conditional();
# line 827 "cs.atg"
	while (Sym == EqualSym ||
	       Sym >= StarEqualSym && Sym <= GreaterGreaterEqualSym) {
# line 827 "cs.atg"
		AssignmentOperator();
# line 827 "cs.atg"
		Expression();
# line 828 "cs.atg"
		
		    if (!doAssign()) 
		                    continue;
		
	}
}

# line 237 "cs.atg"
void cParser::ClassDef()
{
# line 237 "cs.atg"
	Expect(classSym);
# line 237 "cs.atg"
	Expect(identifierSym);
# line 238 "cs.atg"
	
	      // get name
	      char *szName = new char[MAX_IDENTIFIER_LENGTH];
	      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称;
# line 244 "cs.atg"
	ClassBody();
# line 244 "cs.atg"
	Expect(SemicolonSym);
}

# line 245 "cs.atg"
void cParser::ClassBody()
{
# line 246 "cs.atg"
	
	// 利用CFunction来存放类成员
	CFunction* pSaved = this->m_pMainFunction;      // save current function
	CFunction function;
	function.m_SymbolTable.m_pParser = this;
	this->m_pMainFunction = &function;
	
	
# line 255 "cs.atg"
	Expect(LbraceSym);
# line 255 "cs.atg"
	while (Sym == identifierSym ||
	       Sym == classSym ||
	       Sym >= staticSym && Sym <= stringSym) {
# line 255 "cs.atg"
		Definition();
	}
# line 255 "cs.atg"
	Expect(RbraceSym);
# line 257 "cs.atg"
	
	/*
	//添加class
	if (!Error->Errors)
	{
	      CObjDes* pClass = new CObjDes(this);
	      pClass->SetName(szName);
	      if (!pClass)
	      {
	              REPORT_MEM_ERROR("Allcotion memory failed")
	      }
	      else
	      {
	              for (int i = 0; i < function.m_SymbolTable.m_nSymbolCount; i++)
	              {
	                      if (!pClass->AddMember(function.m_SymbolTable.tableEntry[i].szName, 
	                              function.m_SymbolTable.tableEntry[i].type))
	                      {
	                              if (pClass)
	                              {
	                                      delete pClass;
	                                      pClass = NULL;
	                              }
	                              GENERR(118);                                    
	                              break;
	                      }
	              }
	      }
	      if (!this->AddObj(*pClass))
	      {
	              GENERR(119);                            
	              if (pClass)
	              {
	                      delete pClass;
	                      pClass = NULL;
	              }
	      }
	}
	              */
	;
}

# line 346 "cs.atg"
void cParser::VarList(PTYPEDES type, char* szFirstName)
{
# line 347 "cs.atg"
	ArraySize();
# line 348 "cs.atg"
	
	      doVarDecl(type, szFirstName);
	      char szName[MAX_IDENTIFIER_LENGTH];
# line 351 "cs.atg"
	if (Sym == EqualSym) {
# line 351 "cs.atg"
		Get();
# line 351 "cs.atg"
		Expression();
# line 351 "cs.atg"
		doAssign();
	}
# line 352 "cs.atg"
	while (Sym == CommaSym) {
# line 352 "cs.atg"
		Get();
# line 352 "cs.atg"
		Expect(identifierSym);
# line 353 "cs.atg"
		
		              memset(szName, 0, MAX_IDENTIFIER_LENGTH-1);
		              Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH);
		              
		
# line 360 "cs.atg"
		ArraySize();
# line 361 "cs.atg"
		
		               doVarDecl(type, szName);
# line 364 "cs.atg"
		if (Sym == EqualSym) {
# line 364 "cs.atg"
			Get();
# line 364 "cs.atg"
			Expression();
# line 364 "cs.atg"
			        doAssign();
		}
	}
}

# line 367 "cs.atg"
void cParser::ArraySize()
{
# line 367 "cs.atg"
	while (Sym == LbrackSym) {
# line 367 "cs.atg"
		Get();
# line 367 "cs.atg"
		if (Sym >= identifierSym && Sym <= numberSym ||
		    Sym >= stringD1Sym && Sym <= charD1Sym ||
		    Sym == LbraceSym ||
		    Sym == LparenSym ||
		    Sym == StarSym ||
		    Sym == AndSym ||
		    Sym >= PlusSym && Sym <= MinusSym ||
		    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
		    Sym == newSym ||
		    Sym >= BangSym && Sym <= TildeSym) {
# line 367 "cs.atg"
			ConstExpression();
		}
# line 367 "cs.atg"
		Expect(RbrackSym);
	}
}

# line 825 "cs.atg"
void cParser::ConstExpression()
{
# line 825 "cs.atg"
	Expression();
}

# line 422 "cs.atg"
void cParser::FunctionHeader()
{
# line 423 "cs.atg"
	
	    
	
	
# line 430 "cs.atg"
	Expect(LparenSym);
# line 430 "cs.atg"
	if (Sym >= varSym && Sym <= stringSym) {
# line 430 "cs.atg"
		FormalParamList();
	}
# line 430 "cs.atg"
	Expect(RparenSym);
# line 431 "cs.atg"
	        
	this->m_pMainFunction->m_iParamNum = this->m_pMainFunction->m_SymbolTable.m_nSymbolCount; 
	if    (!m_pCurClassDes->getFuncTable()->AddFunction(this->m_pMainFunction))
	           {
	                   GENERR(114);
	           }               
	;
}

# line 439 "cs.atg"
void cParser::FunctionBody()
{
# line 439 "cs.atg"
	CompoundStatement();
# line 439 "cs.atg"
	        ADDCOMMAND0(__ret);
}

# line 440 "cs.atg"
void cParser::FormalParamList()
{
# line 440 "cs.atg"
	FormalParameter();
# line 440 "cs.atg"
	while (Sym == CommaSym) {
# line 440 "cs.atg"
		Get();
# line 440 "cs.atg"
		FormalParameter();
	}
}

# line 555 "cs.atg"
void cParser::CompoundStatement()
{
# line 555 "cs.atg"
	Expect(LbraceSym);
# line 555 "cs.atg"
	while (Sym >= identifierSym && Sym <= numberSym ||
	       Sym >= stringD1Sym && Sym <= charD1Sym ||
	       Sym == SemicolonSym ||
	       Sym == LbraceSym ||
	       Sym >= staticSym && Sym <= stringSym ||
	       Sym == LparenSym ||
	       Sym >= StarSym && Sym <= caseSym ||
	       Sym >= defaultSym && Sym <= ifSym ||
	       Sym >= returnSym && Sym <= switchSym ||
	       Sym == AndSym ||
	       Sym >= PlusSym && Sym <= MinusSym ||
	       Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	       Sym == newSym ||
	       Sym >= BangSym && Sym <= TildeSym) {
# line 555 "cs.atg"
		if (Sym >= staticSym && Sym <= stringSym) {
# line 555 "cs.atg"
			LocalDeclaration();
		} else if (Sym >= identifierSym && Sym <= numberSym ||
		           Sym >= stringD1Sym && Sym <= charD1Sym ||
		           Sym == SemicolonSym ||
		           Sym == LbraceSym ||
		           Sym == LparenSym ||
		           Sym >= StarSym && Sym <= caseSym ||
		           Sym >= defaultSym && Sym <= ifSym ||
		           Sym >= returnSym && Sym <= switchSym ||
		           Sym == AndSym ||
		           Sym >= PlusSym && Sym <= MinusSym ||
		           Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
		           Sym == newSym ||
		           Sym >= BangSym && Sym <= TildeSym) {
# line 555 "cs.atg"
			Statement();
		} else GenError(93);
	}
# line 555 "cs.atg"
	Expect(RbraceSym);
}

# line 441 "cs.atg"
void cParser::FormalParameter()
{
# line 441 "cs.atg"
	PTYPEDES type = new TYPEDES;
# line 442 "cs.atg"
	Type(type);
# line 442 "cs.atg"
	while (Sym == StarSym) {
# line 442 "cs.atg"
		//test;
# line 442 "cs.atg"
		Get();
# line 442 "cs.atg"
		type->refLevel++;
	}
# line 444 "cs.atg"
	Expect(identifierSym);
# line 445 "cs.atg"
	
	   char szName[MAX_IDENTIFIER_LENGTH];
	   memset(szName, 0, MAX_IDENTIFIER_LENGTH-1);
	   Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH);
# line 450 "cs.atg"
	ArraySize();
# line 451 "cs.atg"
	
	     long op;
	     long type1;
	     TYPEDES DT1;
	     
	     if (!m_pMainFunction->PopDigit(&op, &type1, &DT1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE)
	     {
	
	             if (type->objID > 0 && type->type == dtGeneral && type->refLevel == 0)//如果是结构， 生成他的指针
	             {
	                     type->refLevel++;
	             }
	             if (!AllocVar(type, szName))
	                     GENERR(113);
	             else
	                     m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
	     }
	     else
	     {
	             
	             int dimsize[64];//数组最大维数64
	             int i = 0;
	             int arraysize = op;//total size
	             dimsize[i] = op;
	             i++;
	             
	             while (m_pMainFunction->PopDigit(&op, &type1, &DT1))
	             {
	                     dimsize[i] = op;                        
	                     i++;
	                     arraysize *= op;
	             }
	
	             //如果是数组， 分配指针类型
	             long temp;
	             long index;
	             temp = AllocTempVar(type->type, 1);
	             if (temp == -1)
	             {
	                     GENERR(98);
	             }
	             //设置类型和名字
	             index = this->m_pMainFunction->m_SymbolTable.m_nSymbolCount -1;
	             strcpy(m_pMainFunction->m_SymbolTable.tableEntry[index].szName, szName);
	             type->dim = i-1;
	             type->refLevel = 1;
	             memcpy(type->dimsize, dimsize, (i-1)*sizeof(long));
	             memcpy(&m_pMainFunction->m_SymbolTable.tableEntry[index].type, type, sizeof(TYPEDES));
	             m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
	     }
	     delete type;
}

# line 507 "cs.atg"
void cParser::Statement()
{
# line 507 "cs.atg"
	while (Sym == caseSym ||
	       Sym == defaultSym) {
# line 507 "cs.atg"
		Label();
	}
# line 515 "cs.atg"
	switch (Sym) {
		case identifierSym: 
		case numberSym: 
		case stringD1Sym: 
		case charD1Sym: 
		case LbraceSym: 
		case LparenSym: 
		case StarSym: 
		case AndSym: 
		case PlusSym: 
		case MinusSym: 
		case PlusPlusSym: 
		case MinusMinusSym: 
		case newSym: 
		case BangSym: 
		case TildeSym:  
# line 515 "cs.atg"
			AssignmentStatement();
			break;
		case breakSym:  
# line 515 "cs.atg"
			BreakStatement();
			break;
		case continueSym:  
# line 516 "cs.atg"
			ContinueStatement();
			break;
		case doSym:  
# line 517 "cs.atg"
			DoStatement();
			break;
		case forSym:  
# line 517 "cs.atg"
			ForStatement();
			break;
		case ifSym:  
# line 518 "cs.atg"
			IfStatement();
			break;
		case SemicolonSym:  
# line 518 "cs.atg"
			NullStatement();
			break;
		case returnSym:  
# line 519 "cs.atg"
			ReturnStatement();
			break;
		case switchSym:  
# line 519 "cs.atg"
			SwitchStatement();
			break;
		case whileSym:  
# line 520 "cs.atg"
			WhileStatement();
			break;
		default :GenError(94); break;
	}
# line 520 "cs.atg"
	        m_pMainFunction->ClearExpStack();
}

# line 523 "cs.atg"
void cParser::Label()
{
# line 523 "cs.atg"
	if (Sym == caseSym) {
# line 523 "cs.atg"
		Get();
# line 523 "cs.atg"
		ConstExpression();
# line 523 "cs.atg"
		Expect(ColonSym);
	} else if (Sym == defaultSym) {
# line 523 "cs.atg"
		Get();
# line 523 "cs.atg"
		Expect(ColonSym);
	} else GenError(95);
}

# line 528 "cs.atg"
void cParser::AssignmentStatement()
{
# line 528 "cs.atg"
	Expression();
# line 528 "cs.atg"
	Expect(SemicolonSym);
}

# line 530 "cs.atg"
void cParser::BreakStatement()
{
# line 530 "cs.atg"
	Expect(breakSym);
# line 530 "cs.atg"
	Expect(SemicolonSym);
# line 531 "cs.atg"
	        //recode this command for write back
	   this->m_curloop->AddBreak(this->m_pMainFunction->m_nCurrentCmdNum);
	   //add command
	   ADDCOMMAND1(__jmp, CC, 0);      
}

# line 557 "cs.atg"
void cParser::ContinueStatement()
{
# line 557 "cs.atg"
	Expect(continueSym);
# line 557 "cs.atg"
	Expect(SemicolonSym);
# line 558 "cs.atg"
	
	    //recode this command for write back
	    this->m_curloop->AddContinue(this->m_pMainFunction->m_nCurrentCmdNum);
	    //add command
	    ADDCOMMAND1(__jmp, CC, 0);      
	
}

# line 567 "cs.atg"
void cParser::DoStatement()
{
# line 567 "cs.atg"
	Expect(doSym);
# line 567 "cs.atg"
	Statement();
# line 567 "cs.atg"
	Expect(whileSym);
# line 567 "cs.atg"
	Expect(LparenSym);
# line 567 "cs.atg"
	Expression();
# line 567 "cs.atg"
	Expect(RparenSym);
# line 567 "cs.atg"
	Expect(SemicolonSym);
}

# line 569 "cs.atg"
void cParser::ForStatement()
{
# line 569 "cs.atg"
	Expect(forSym);
# line 569 "cs.atg"
	Expect(LparenSym);
# line 569 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym == newSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 569 "cs.atg"
		Expression();
	}
# line 569 "cs.atg"
	Expect(SemicolonSym);
# line 570 "cs.atg"
	
	    //循环从下一句开始
	    int loopEntry = this->m_pMainFunction->m_nCurrentCmdNum;
	    int jzCmd = 0;
	    
	    //压栈
	    this->AddNewLoop();//添加一个新的looptree
	    this->m_curloop->m_entry = loopEntry;//设置新looptree的入口
	
	;
# line 582 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym == newSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 582 "cs.atg"
		Expression();
	}
# line 583 "cs.atg"
	
	            //add command jz
	            jzCmd = this->m_pMainFunction->m_nCurrentCmdNum;
	            ADDCOMMAND1(__jnz, CC, 0)
	;
# line 589 "cs.atg"
	Expect(SemicolonSym);
# line 590 "cs.atg"
	
	    PCOMMAND cmd = NULL;
	    int cmdsaved;
	    int cmdnum;
	
	
# line 597 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym == newSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 598 "cs.atg"
		
		              cmdsaved = this->m_pMainFunction->m_nCurrentCmdNum;
# line 601 "cs.atg"
		Expression();
# line 602 "cs.atg"
		
		              cmdnum = this->m_pMainFunction->m_nCurrentCmdNum - cmdsaved;
		              cmd = new COMMAND[cmdnum];    
		              //save expression cmd to insert before jmp command
		              long t=cmdnum*sizeof(COMMAND);
		              memcpy(cmd, &(m_pMainFunction->m_pCmdTable[cmdsaved]), cmdnum*sizeof(COMMAND));
		              m_pMainFunction->m_nCurrentCmdNum = cmdsaved;           
		
	}
# line 611 "cs.atg"
	Expect(RparenSym);
# line 611 "cs.atg"
	Statement();
# line 612 "cs.atg"
	
	    long nContinue;//continue 语句的跳转目的地。
	    nContinue = this->m_pMainFunction->m_nCurrentCmdNum;
	    this->m_curloop->SetContinue(nContinue);
	
	    //insert saved cmd
	    for (int i = 0; i< cmdnum; i++)
	    {
	            m_pMainFunction->AddCommand(cmd[i]);
	    }
	    delete cmd;
	    //change loop variable
	    //jump back
	    ADDCOMMAND1(__jmp, CC, loopEntry);      
	    //write back jz instructment
	    this->m_pMainFunction->m_pCmdTable[jzCmd].op[0] = this->m_pMainFunction->m_nCurrentCmdNum;
	    //write back break continue statement
	    this->m_curloop->SetExit(this->m_pMainFunction->m_nCurrentCmdNum);
	    this->ExitCurLoop();//destroy current loop tree
	;
}

# line 634 "cs.atg"
void cParser::IfStatement()
{
# line 634 "cs.atg"
	Expect(ifSym);
# line 634 "cs.atg"
	Expect(LparenSym);
# line 634 "cs.atg"
	Expression();
# line 634 "cs.atg"
	Expect(RparenSym);
# line 635 "cs.atg"
	
	    //判断
	    {
	            long op1;
	            long type1;
	            TYPEDES dt1;
	            //pop
	            if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
	            {
	                    //      REPORT_COMPILE_ERROR("POP UP FAILED");
	                    GENERR(96);
	                    return;
	            }
	            else
	            {
	                    if (dt1.type == dtFloat)
	                    {
	                            GENERR(112);
	                    }
	                    else
	                    {
	                            //get address mode
	                            int address_mode = (type1<<8);
	                            address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);     
	                            address_mode |= AMODE_DIRECT;
	                            //add commmand to command table
	                            ADDCOMMAND3(__test, address_mode, op1, 0, 0)    
	                    }
	            }
	    }
	
	    //记录跳转指令的序号
	    int jzcmd = this->m_pMainFunction->m_nCurrentCmdNum;
	    //加入判断语句
	    ADDCOMMAND1(__jz, CC, 0)//跳转目标在下面补上;
# line 671 "cs.atg"
	Statement();
# line 671 "cs.atg"
	        int nextcmd; bool bElse = false;
# line 671 "cs.atg"
	if (Sym == elseSym) {
# line 673 "cs.atg"
		Get();
# line 674 "cs.atg"
		
		            bElse = true;
		            int jmpcmd = this->m_pMainFunction->m_nCurrentCmdNum;
		            ADDCOMMAND1(__jmp, CC, 0);
		            //补上jnz的跳转目标
		            nextcmd = this->m_pMainFunction->m_nCurrentCmdNum;
		            this->m_pMainFunction->m_pCmdTable[jzcmd].op[0] = nextcmd;
		
# line 683 "cs.atg"
		Statement();
# line 684 "cs.atg"
		
		            nextcmd = this->m_pMainFunction->m_nCurrentCmdNum;
		            //补上jmp的跳转目标
		            this->m_pMainFunction->m_pCmdTable[jmpcmd].op[0] = nextcmd;
		
	}
# line 691 "cs.atg"
	
	if (!bElse)
	{
	           //补上jnz的跳转目标
	           nextcmd = this->m_pMainFunction->m_nCurrentCmdNum;
	           this->m_pMainFunction->m_pCmdTable[jzcmd].op[0] = nextcmd;
	   };
}

# line 701 "cs.atg"
void cParser::NullStatement()
{
# line 701 "cs.atg"
	Expect(SemicolonSym);
}

# line 703 "cs.atg"
void cParser::ReturnStatement()
{
# line 703 "cs.atg"
	Expect(returnSym);
# line 703 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym == newSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 703 "cs.atg"
		Expression();
	}
# line 704 "cs.atg"
	
	    //pop
	    long op1;
	    long type;
	    TYPEDES dt1;
	    if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE )
	    {
	    //      REPORT_COMPILE_ERROR("POP UP FAILED");
	            GENERR(96);
	            return;
	    }
	    int address_mode = type&0x00ff;
	    address_mode |= (log2(UnitSize(dt1))<<6);
	    
	    //ADDCOMMAND
	    // move reutrn value to _ax
	    ADDCOMMAND2(__mov, address_mode|0x8200, _AX, op1);
	    // return
	    ADDCOMMAND0(__ret);
	
# line 725 "cs.atg"
	Expect(SemicolonSym);
}

# line 728 "cs.atg"
void cParser::SwitchStatement()
{
# line 728 "cs.atg"
	Expect(switchSym);
# line 728 "cs.atg"
	Expect(LparenSym);
# line 730 "cs.atg"
	Expression();
# line 733 "cs.atg"
	Expect(RparenSym);
# line 733 "cs.atg"
	Statement();
}

# line 737 "cs.atg"
void cParser::WhileStatement()
{
# line 737 "cs.atg"
	Expect(whileSym);
# line 737 "cs.atg"
	Expect(LparenSym);
# line 738 "cs.atg"
	
	  int loopentry = this->m_pMainFunction->m_nCurrentCmdNum;
	
	  //压栈
	  this->AddNewLoop();//添加一个新的looptree
	  this->m_curloop->m_entry = loopentry;//设置新looptree的入口
	
	;
# line 747 "cs.atg"
	Expression();
# line 748 "cs.atg"
	
	//判断
	{
	   long op1;
	   long type1;
	   TYPEDES dt1;
	   //pop
	   if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
	   {
	           //      REPORT_COMPILE_ERROR("POP UP FAILED");
	           GENERR(96);
	           return;
	   }
	   else
	   {
	           if (dt1.type == dtFloat)
	           {
	                   GENERR(112);
	           }
	           else
	           {
	                   //get address mode
	                   int address_mode = (type1<<8);
	                   address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);     
	                   address_mode |= AMODE_DIRECT;
	                   //add commmand to command table
	                   ADDCOMMAND3(__test, address_mode, op1, 0, 0)    
	           }
	   }
	}
	
	int jnzCmd =  this->m_pMainFunction->m_nCurrentCmdNum;
	//jnz command
	ADDCOMMAND1(__jz, CC, 0);
# line 783 "cs.atg"
	Expect(RparenSym);
# line 783 "cs.atg"
	Statement();
# line 785 "cs.atg"
	
	 long nContinue;//continue 语句的跳转目的地。
	 nContinue = this->m_pMainFunction->m_nCurrentCmdNum;
	 this->m_curloop->SetContinue(nContinue);
	
	 //jmp back
	 ADDCOMMAND1(__jmp, CC, loopentry);
	 //write back jnz
	 this->m_pMainFunction->m_pCmdTable[jnzCmd].op[0] = this->m_pMainFunction->m_nCurrentCmdNum;
	
	 this->m_curloop->SetExit(this->m_pMainFunction->m_nCurrentCmdNum);
	 this->ExitCurLoop();//destroy current loop tree
	;
}

# line 537 "cs.atg"
void cParser::LocalDeclaration()
{
# line 538 "cs.atg"
	
	      PTYPEDES type = new TYPEDES;
	      char szName[MAX_IDENTIFIER_LENGTH];
	      
	
# line 543 "cs.atg"
	if (Sym >= varSym && Sym <= stringSym) {
# line 543 "cs.atg"
		Type(type);
	} else if (Sym >= staticSym && Sym <= functionSym) {
# line 543 "cs.atg"
		StorageClass();
# line 543 "cs.atg"
		if (Sym >= varSym && Sym <= stringSym) {
# line 543 "cs.atg"
			Type(type);
		}
	} else GenError(96);
# line 549 "cs.atg"
	Expect(identifierSym);
# line 549 "cs.atg"
	        
	                      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	                      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);
	              
# line 553 "cs.atg"
	VarList(type, szName);
# line 553 "cs.atg"
	Expect(SemicolonSym);
# line 553 "cs.atg"
	delete type;
}

# line 835 "cs.atg"
void cParser::Conditional()
{
# line 835 "cs.atg"
	LogORExp();
}

# line 2134 "cs.atg"
void cParser::AssignmentOperator()
{
# line 2134 "cs.atg"
	switch (Sym) {
		case EqualSym:  
# line 2134 "cs.atg"
			Get();
			break;
		case StarEqualSym:  
# line 2134 "cs.atg"
			Get();
			break;
		case SlashEqualSym:  
# line 2134 "cs.atg"
			Get();
			break;
		case PercentEqualSym:  
# line 2134 "cs.atg"
			Get();
			break;
		case PlusEqualSym:  
# line 2134 "cs.atg"
			Get();
			break;
		case MinusEqualSym:  
# line 2134 "cs.atg"
			Get();
			break;
		case AndEqualSym:  
# line 2134 "cs.atg"
			Get();
			break;
		case UparrowEqualSym:  
# line 2135 "cs.atg"
			Get();
			break;
		case BarEqualSym:  
# line 2135 "cs.atg"
			Get();
			break;
		case LessLessEqualSym:  
# line 2135 "cs.atg"
			Get();
			break;
		case GreaterGreaterEqualSym:  
# line 2135 "cs.atg"
			Get();
			break;
		default :GenError(97); break;
	}
}

# line 837 "cs.atg"
void cParser::LogORExp()
{
# line 837 "cs.atg"
	LogANDExp();
# line 837 "cs.atg"
	        int type = -1;
# line 837 "cs.atg"
	while (Sym == BarBarSym) {
# line 837 "cs.atg"
		Get();
# line 839 "cs.atg"
		
		            type = 7;
# line 842 "cs.atg"
		LogANDExp();
# line 843 "cs.atg"
		
		              //add command
		              long op1, op2;
		              long type1, type2;
		              TYPEDES dt1, dt2;
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		              //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		                      //add commmand to command table
		                      ADDCOMMAND3(__test, address_mode, op1, op2, 7/*==*/)                                    
		                      //push result
		                      TYPEDES dt;//not used
		                      memset(&dt, 0, sizeof(TYPEDES));
		                      this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		              };
	}
# line 871 "cs.atg"
	
	      if (type >= 0)
	      {
	              long g;
	              long t;
	              TYPEDES DT;
	              m_pMainFunction->PopDigit(&g, &t, &DT);
	              //将结果存入临时变量
	              
	              _typedes(DT1, dtLong)
	              if (m_pMainFunction->AddVal(NULL, DT1))
	              {
	                      long temp;
	                      temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                      ADDCOMMAND2(__mov, DR, temp, _PSW);
	                      m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
	              }
	              else
	              {
	                      REPORT_COMPILE_ERROR("add symbol failed");
	              }
	      };
}

# line 896 "cs.atg"
void cParser::LogANDExp()
{
# line 897 "cs.atg"
	        
	int type = -1;
	    long op1, op2;
	    long type1, type2;
	    TYPEDES dt1, dt2;
# line 904 "cs.atg"
	InclORExp();
# line 904 "cs.atg"
	while (Sym == AndAndSym) {
# line 904 "cs.atg"
		Get();
# line 906 "cs.atg"
		                type = 7;
# line 908 "cs.atg"
		InclORExp();
# line 910 "cs.atg"
		
		              //add command
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		              //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		                      //add commmand to command table
		                      ADDCOMMAND3(__test, address_mode, op1, op2, 6/*==*/)                                    
		                      //push result
		                      TYPEDES dt;//not used
		                      memset(&dt, 0, sizeof(TYPEDES));
		                      this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		              }
		;
	}
# line 935 "cs.atg"
	
	      if (type >= 0)
	      {
	              long g;
	              long t;
	              TYPEDES dt;
	              m_pMainFunction->PopDigit(&g, &t, &dt);
	              
	              //将结果存入临时变量
	              if (m_pMainFunction->AddVal(NULL, dt1))
	              {                       
	                      long temp;
	                      temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                      ADDCOMMAND2(__mov, DR, temp, _PSW);
	                      m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
	              }
	              else
	              {
	                      REPORT_COMPILE_ERROR("add symbol failed");
	              }
	              };
}

# line 959 "cs.atg"
void cParser::InclORExp()
{
# line 959 "cs.atg"
	ExclORExp();
# line 959 "cs.atg"
	while (Sym == BarSym) {
# line 959 "cs.atg"
		Get();
# line 959 "cs.atg"
		ExclORExp();
	}
}

# line 961 "cs.atg"
void cParser::ExclORExp()
{
# line 961 "cs.atg"
	ANDExp();
# line 961 "cs.atg"
	while (Sym == UparrowSym) {
# line 961 "cs.atg"
		Get();
# line 961 "cs.atg"
		ANDExp();
	}
}

# line 963 "cs.atg"
void cParser::ANDExp()
{
# line 963 "cs.atg"
	EqualExp();
# line 963 "cs.atg"
	while (Sym == AndSym) {
# line 963 "cs.atg"
		Get();
# line 963 "cs.atg"
		EqualExp();
	}
}

# line 965 "cs.atg"
void cParser::EqualExp()
{
# line 966 "cs.atg"
	
	    int type = -1;//0: == 1: !=
	    long op1, op2;
	    long type1, type2;
	    TYPEDES dt1, dt2;
	
# line 974 "cs.atg"
	RelationExp();
# line 974 "cs.atg"
	while (Sym >= EqualEqualSym && Sym <= BangEqualSym) {
# line 976 "cs.atg"
		if (Sym == EqualEqualSym) {
# line 974 "cs.atg"
			Get();
# line 975 "cs.atg"
			                        type = 0;
		} else if (Sym == BangEqualSym) {
# line 976 "cs.atg"
			Get();
# line 977 "cs.atg"
			
			                      type = 1;
			
		} else GenError(98);
# line 980 "cs.atg"
		RelationExp();
# line 982 "cs.atg"
		
		              //add command
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		              //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		
		                      //add commmand to command table
		                      if (type == 0)
		                      {       
		                              ADDCOMMAND3(__test, address_mode, op1, op2, 0/*==*/)                                    
		                      }
		                      else if (type == 1)
		                      {
		                              ADDCOMMAND3(__test, address_mode, op1, op2, 1/*==*/)    
		                      }
		
		                      //push result
		                      TYPEDES dt;//not used
		                      memset(&dt, 0, sizeof(TYPEDES));
		                      this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		              }
		;
	}
# line 1017 "cs.atg"
	
	      if (type >= 0)
	      {
	              long g;
	              long t;
	              TYPEDES dt;
	              if (m_pMainFunction->PopDigit(&g, &t, &dt))
	              {
	                      //将结果存入临时变量
	                      if (m_pMainFunction->AddVal(NULL,  dt1))
	                      {                       
	                              long temp;
	                              temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                              ADDCOMMAND2(__mov, DR, temp , _PSW);
	                              m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
	                      }
	                      else
	                      {
	                              REPORT_COMPILE_ERROR("add symbol failed");
	                      }
	              }
	      };
}

# line 1042 "cs.atg"
void cParser::RelationExp()
{
# line 1043 "cs.atg"
	
	    int type = -1;
	    long op1, op2;
	    long type1, type2;
	    TYPEDES dt1, dt2;
	
# line 1050 "cs.atg"
	ShiftExp();
# line 1050 "cs.atg"
	while (Sym >= LessSym && Sym <= GreaterEqualSym) {
# line 1050 "cs.atg"
		switch (Sym) {
			case LessSym:  
# line 1050 "cs.atg"
				Get();
# line 1050 "cs.atg"
				type = 5;
				break;
			case GreaterSym:  
# line 1050 "cs.atg"
				Get();
# line 1050 "cs.atg"
				type = 4;
				break;
			case LessEqualSym:  
# line 1050 "cs.atg"
				Get();
# line 1050 "cs.atg"
				type = 3;
				break;
			case GreaterEqualSym:  
# line 1050 "cs.atg"
				Get();
# line 1050 "cs.atg"
				type = 2;
				break;
			default :GenError(99); break;
		}
# line 1051 "cs.atg"
		ShiftExp();
# line 1053 "cs.atg"
		
		            //add command
		            //pop出乘数和被乘数
		            if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		            {
		            //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                    GENERR(96);
		                    return;
		            }
		            else
		            {
		                    CAST
		                    //get address mode
		                    int address_mode = (type1<<8)|(short)type2;
		                    address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		
		                    //add commmand to command table
		                    ADDCOMMAND3(__test, address_mode, op1, op2, type)                                       
		
		                    //push result
		                    TYPEDES dt;//not used
		                    memset(&dt, 0, sizeof(TYPEDES));
		                    this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		            }
		
		;
	}
# line 1082 "cs.atg"
	
	    if (type >= 0)
	    {
	            // pop掉多于的操作数, 因为这时结果已在__AX中
	            long g;
	            long t;
	            TYPEDES dt;
	            m_pMainFunction->PopDigit(&g, &t, &dt);
	
	            //将结果存入临时变量
	            _typedes(dt_temp, dtLong)
	            if (m_pMainFunction->AddVal(NULL,  dt_temp))
	            {                       
	                    long temp;
	                    temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                    ADDCOMMAND2(__mov, DR, temp, _PSW);
	                    m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt_temp);
	            }
	            else
	            {
	                    REPORT_COMPILE_ERROR("add symbol failed");
	            }
	    };
}

# line 1108 "cs.atg"
void cParser::ShiftExp()
{
# line 1108 "cs.atg"
	AddExp();
# line 1108 "cs.atg"
	while (Sym >= LessLessSym && Sym <= GreaterGreaterSym) {
# line 1108 "cs.atg"
		if (Sym == LessLessSym) {
# line 1108 "cs.atg"
			Get();
		} else if (Sym == GreaterGreaterSym) {
# line 1108 "cs.atg"
			Get();
		} else GenError(100);
# line 1108 "cs.atg"
		AddExp();
	}
}

# line 1110 "cs.atg"
void cParser::AddExp()
{
# line 1110 "cs.atg"
	        int type = -1;//1: add 0: sub;
# line 1111 "cs.atg"
	MultExp();
# line 1111 "cs.atg"
	while (Sym >= PlusSym && Sym <= MinusSym) {
# line 1111 "cs.atg"
		if (Sym == PlusSym) {
# line 1111 "cs.atg"
			Get();
# line 1111 "cs.atg"
			        type = 1;
		} else if (Sym == MinusSym) {
# line 1111 "cs.atg"
			Get();
# line 1111 "cs.atg"
			type = 0;
		} else GenError(101);
# line 1111 "cs.atg"
		MultExp();
# line 1113 "cs.atg"
		
		              //add command
		              long op1, op2;
		              long type1, type2;
		              TYPEDES dt1, dt2;
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		              //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		
		                      //类型转换
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		
		                      
		                      if (dt1.dim >0)
		                      {//如果是数组变量
		                              //得到增量
		                              int size = UnitSize(dt1);
		                              for (int i=1; i<dt1.dim;i++)
		                              {
		                                      size *= dt1.dimsize[i];
		                              }
		                              //增量乘以op2得到实际增量,存入_AX
		                              ADDCOMMAND2(__mul, type2<<8, op2, size)
		                              //加法
		                              if (dt1.type == dtFloat && dt1.refLevel==0)
		                              {
		                                      if (type == 0)
		                                      ADDCOMMAND2(__fsub, (type1<<8)|0x82, op1, _AX)  
		                                      else if (type == 1)
		                                      ADDCOMMAND2(__fadd, (type1<<8)|0x82, op1, _AX)  
		                              }
		                              else
		                              {
		                                      if (type == 0)
		                                      ADDCOMMAND2(__sub, (type1<<8)|0x82, op1, _AX)   
		                                      else if (type == 1)
		                                      ADDCOMMAND2(__add, (type1<<8)|0x82, op1, _AX)   
		                              }
		                      }
		                      else
		                      {
		                              //add commmand to command table
		                              if (dt1.type == dtFloat && dt1.refLevel==0)
		                              {
		                                      if (type == 0)
		                                      ADDCOMMAND2(__fsub, address_mode, op1, op2)     
		                                      else if (type == 1)
		                                      ADDCOMMAND2(__fadd, address_mode, op1, op2)     
		                              }
		                              else
		                              {
		                                      if (type == 0)
		                                      ADDCOMMAND2(__sub, address_mode, op1, op2)      
		                                      else if (type == 1)
		                                      ADDCOMMAND2(__add, address_mode, op1, op2)      
		                              }
		                      }       
		                      //将AX中的结果存入临时变量
		                      if (m_pMainFunction->AddVal(NULL,  dt1))
		                      {                       
		                              long temp;
		                              long opsize = log2(UnitSize(dt1))<<6;
		                              temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
		                              ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp , _AX);
		                              m_pMainFunction->PushDigit(temp, AMODE_MEM|opsize, dt1);
		                      }
		                      else
		                      {
		                              REPORT_COMPILE_ERROR("add symbol failed");
		                      }
		              };
	}
}

# line 1197 "cs.atg"
void cParser::MultExp()
{
# line 1197 "cs.atg"
	        char szName[MAX_IDENTIFIER_LENGTH];     memset(szName, 0, MAX_IDENTIFIER_LENGTH);
# line 1198 "cs.atg"
	CastExp();
# line 1199 "cs.atg"
	
	     Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
	     int type = -1;//0: mult 1: div 2:percent;
# line 1202 "cs.atg"
	while (Sym == StarSym ||
	       Sym >= SlashSym && Sym <= PercentSym) {
# line 1202 "cs.atg"
		if (Sym == StarSym) {
# line 1202 "cs.atg"
			Get();
# line 1202 "cs.atg"
			        type = 0;
		} else if (Sym == SlashSym) {
# line 1202 "cs.atg"
			Get();
# line 1202 "cs.atg"
			        type = 1;
		} else if (Sym == PercentSym) {
# line 1202 "cs.atg"
			Get();
# line 1202 "cs.atg"
			        type = 2;
		} else GenError(102);
# line 1202 "cs.atg"
		CastExp();
# line 1203 "cs.atg"
		
		              Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
		              
		              //add command
		              long op1, op2;
		              long type1, type2;
		              TYPEDES dt1, dt2;
		
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) ||type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		                      //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		                      //add commmand to command table
		                      if (dt1.type == dtFloat && dt1.refLevel==0)
		                      {
		                              if (type == 0) ADDCOMMAND2(__fmul, address_mode, op1, op2)                                      
		                                      else if (type == 1) ADDCOMMAND2(__fdiv, address_mode, op1, op2)                                 
		                                      else GENERR(109);
		                      }
		                      else
		                      {
		                              if (type == 0) ADDCOMMAND2(__mul, address_mode, op1, op2)                                       
		                                      else if (type == 1) ADDCOMMAND2(__div, address_mode, op1, op2)
		                                      else if (type == 2) ADDCOMMAND2(__mod, address_mode, op1, op2)
		                      }
		                      
		                      //将AX中的结果存入临时变量
		                      if (m_pMainFunction->AddVal(NULL, dt1))
		                      {                       
		                              long temp;
		                              long opsize = log2(UnitSize(dt1))<<6;
		                              temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
		                              ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp, _AX);
		                              m_pMainFunction->PushDigit(temp, AMODE_MEM|opsize, dt1);
		                      }
		                      else
		                      {
		                              GENERR(98);
		                      }
		              }
		;
	}
}

# line 1256 "cs.atg"
void cParser::CastExp()
{
# line 1257 "cs.atg"
	
	    //保存一元操作符栈
	    EXPRESSIONOP* pSavedStack = this->m_pExpOpPt;
	    //清空一元操作符栈
	    m_pExpOpPt = &m_ExpOp;
	    //int op;
	
# line 1265 "cs.atg"
	UnaryExp();
# line 1267 "cs.atg"
	
	    int op;
	    while (this->PopOp(&op))
	    {               
	
	            //操作数出栈
	            long op1;
	            long type1;
	            TYPEDES dt1;    
	            if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) ||type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE)
	            {
	                    break;//GENERR(96);
	            }
	            int address_mode = (type1<<8);
	            address_mode |= log2(UnitSize(dt1))<<14;
	            
	            //添加命令
	            switch (op)
	            {
	            case PlusSym:                           
	                    //no operation
	                    break;
	            case MinusSym:                  
	                    {
	                            int opsize;
	                            if (!m_pMainFunction->AddVal(NULL, dt1))
	                                    GENERR(98);
	                            if (dt1.type == dtFloat)
	                            {
	                                    opsize = (type1>>6)&0xc0;
	                                    ADDCOMMAND2(__fsub, type1, 0, op1)
	                            }
	                            else
	                            {
	                                    opsize = (type1>>6)&0xc0;
	                                    ADDCOMMAND2(__sub, type1, 0, op1)
	                            }
	                            ADDCOMMAND2(__mov, DR, m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, _AX)
	                            m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, AMODE_MEM|(opsize<<6), dt1);
	                    }
	                    break;
	            case StarSym:  
	                    {
	                            if (dt1.refLevel <1)
	                                    GENERR(102);
	                            dt1.refLevel--;
	                            //取操作的字节类型
	                            int opsize = log2(UnitSize(dt1));
	                            opsize = opsize<< 6;
	                            type1 |= opsize; 
	
	                            //将type1的间接访问级别提高一级
	                            int level = (type1 & 0x30) >> 4;
	                            if (level == 3)
	                            {
	                                    GENERR(103);
	                                    break;
	                            }
	                            level ++;
	                            type1 |= level << 4;
	/*                              int j = (type1>>4)&0x3;
	                            if (j < 1)
	                                    GENERR(102);//is not a point
	                            else
	                                    j--;
	                            j = j << 4;
	*/                              
	/*                      
	                            type1 &= 0xffcf;
	                            type1 |= j;
	*/
	                            //入栈
	                            m_pMainFunction->PushDigit(op1, type1, dt1);
	                    }
	                    break;
	            case BangSym: 
	                    {
	                            if (!m_pMainFunction->AddVal(NULL, dt1))
	                                    GENERR(98);
	                            int opsize = (type1>>6)&0x03;
	                            ADDCOMMAND2(__mov, (0x100|(opsize<<14))|(type1), m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, op1)
	                            ADDCOMMAND1(__notr, type1<<8, m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address)
	                            m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, type1, dt1);
	                    }
	                    break;
	            case AndSym:  
	                    {
	                            long temp;
	                            temp = AllocTempVar(dtLong, 1);
	                            if (temp == -1)
	                            {
	                                    GENERR(98);
	                            }
	                            else
	                            {
	                                    if (dt1.objID > 0)
	                                    {//如果时obj， 不取地址
	                                            m_pMainFunction->PushDigit(op1, type1, dt1);
	                                    }
	                                    else
	                                    {
	                                            ADDCOMMAND2(__ea, 0x8100|type1, temp, op1)
	                                            dt1.refLevel ++;
	                                            m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
	                                    }
	                            }
	                    }
	                    break;
	            case TildeSym: //'~'
	                    {
	                            if (!m_pMainFunction->AddVal(NULL, dt1))
	                                    GENERR(98);
	                            int opsize = (type1>>6)&0xc0;
	                            ADDCOMMAND2(__mov, (0x100|(opsize<<14))|(type1), m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, op1)
	                            ADDCOMMAND1(__not, type1<<8, m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address)
	                            m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, type1, dt1);
	                    }
	                    break;
	            default :GENERR(93); break;
	            }               
	    }
	    //恢复一元运算符栈
	    this->ClearOpStack();
	    m_pExpOpPt = pSavedStack;  
}

# line 1398 "cs.atg"
void cParser::UnaryExp()
{
# line 1399 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == newSym) {
# line 1398 "cs.atg"
		PostFixExp();
	} else if (Sym >= PlusPlusSym && Sym <= MinusMinusSym) {
# line 1399 "cs.atg"
		if (Sym == PlusPlusSym) {
# line 1399 "cs.atg"
			Get();
		} else if (Sym == MinusMinusSym) {
# line 1399 "cs.atg"
			Get();
		} else GenError(103);
# line 1399 "cs.atg"
		UnaryExp();
	} else if (Sym == StarSym ||
	           Sym == AndSym ||
	           Sym >= PlusSym && Sym <= MinusSym ||
	           Sym >= BangSym && Sym <= TildeSym) {
# line 1400 "cs.atg"
		UnaryOperator();
# line 1400 "cs.atg"
		CastExp();
	} else GenError(104);
}

# line 1406 "cs.atg"
void cParser::PostFixExp()
{
# line 1406 "cs.atg"
	Primary();
# line 1407 "cs.atg"
	while (Sym == identifierSym ||
	       Sym == LbrackSym ||
	       Sym == LparenSym ||
	       Sym >= PlusPlusSym && Sym <= MinusGreaterSym) {
# line 1479 "cs.atg"
		switch (Sym) {
			case LbrackSym:  
# line 1407 "cs.atg"
				Get();
# line 1407 "cs.atg"
				Expression();
# line 1407 "cs.atg"
				Expect(RbrackSym);
# line 1408 "cs.atg"
				
				{
				                              //add command
				                              long op1, op2;
				                              long type1, type2;
				                              TYPEDES dt1, dt2;
				                              //pop
				                              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
				                              {
				                                      //      REPORT_COMPILE_ERROR("POP UP FAILED");
				                                      GENERR(96);
				                                      return;
				                                      
				                              }
				                              else
				                              {       
				                              /*处理a[b]的流程(要考虑指针， 数组， 多维数组， 作为参数传进来的数组和指针）
				                                      1. 得到b下标代表的单位长度(如果是数组, 通过维数计算, 如果是指针, reflvl减一后计算UnitSize)
				                                      2. b*单位长度= offset 
				                                      3. a + offset -> temp
				                                      4. push temp, 间接寻址
				                                      */
				                                      int offset;
				                                      BOOL bIsArray = TRUE;
				                                      if (dt1.dim >0)//是数组
				                                      {
				                                              bIsArray = TRUE;
				                                              offset= UnitSize(dt1);
				                                              for (int i = 1; i< dt1.dim; i++)
				                                              {
				                                                      offset *= dt1.dimsize[i];
				                                              }
				                                              //不生成新的typedes, 直接修改dt1, 使之维数减一
				                                              if (dt1.dim >1)
				                                                      memcpy(dt1.dimsize, dt1.dimsize+1, sizeof(long)*(dt1.dim-1));                                   
				                                              dt1.dim--;                                                      
				                                      }
				                                      else
				                                      {//不是数组, 是指针
				                                              bIsArray = FALSE;
				                                              if (dt1.refLevel > 0)//是指针且不是指针数组
				                                              {
				                                                      //不生成新的typedes, 直接修改dt1, 使之*号减一
				                                                      dt1.refLevel--;
				                                                      offset = UnitSize(dt1);
				                                              }
				                                              else//既不是指针也不是数组
				                                                      GENERR(101);                                            
				                                      }
				
				                                      //偏移量 = 单位长度* 下标addcommand(mul, DC, 下标, 单位长度)
				                                      ADDCOMMAND2(__mul, (type2<<8)|0x8080, op2, offset)
				                                      //增加临时变量存放中间结果
				                                      long temp = this->AllocTempVar(dtLong);
				                                      if (temp == -1)
				                                      {
				                                              GENERR(98);
				                                      }
				                                      //居卫华2001-08-22
				                                      long lIndirect = (type1>>4)&0x03;
				                                      if (bIsArray == FALSE && lIndirect>0)//如果是指针， 则间接寻址
				                                              ADDCOMMAND2(__add, DR|0x1000, op1, _AX)
				                                      else
				                                              ADDCOMMAND2(__add, DR, op1, _AX)
				                                      //将结果保存到temp
				                                      ADDCOMMAND2(__mov, DR, temp, _AX)
				                                      //入栈, 作为指针用
				                                      m_pMainFunction->PushDigit(temp, AMODE_MEM|0x10|((log2(UnitSize(dt1)))<<6), dt1);
				}
				};
				break;
			case LparenSym:  
# line 1480 "cs.atg"
				        
				{
				                      char szName[MAX_IDENTIFIER_LENGTH];
				                      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
				                      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
				                      long index = m_PubFuncTable->FindFuncByName(szName);
				                      FUNCCALL fn;
				                      fn.name = szName;
				                      if (index < 0) // cannot find function name in public function table, guess is was class method
				                      {
				                              if (m_pCurClassDes){ // if in class scope
				                                      // find in script function table
				                                      CFunction* pScript = m_pCurClassDes->getFuncTable()->GetFunction(szName, &index);
				                                      if (pScript == NULL)
				                                      {       
				                                              GENERR(97);
				                                              Get();
				                                              return;
				                                      }
				                                      else{
				                                              fn.pVF = pScript;
				                                              fn.nType = 0;
				                                              ADDCOMMAND1(__callv, CC, (long)pScript);
				                                              
				                                              // add "this" as first parameter
				                                              ADDCOMMAND1(__paramv, 0x5100, 0);
				                                              
				                                              m_pCurClassDes->getFuncTable()->ReleaseFunc();
				                                      }
				                              }
				                              else{
				                                      // TODO support non-class function
				                              }
				                      }
				                      else
				                      {
				                              ADDCOMMAND1(__callpub, CC, (long)(this->m_PubFuncTable->m_FuncTable[index].pfn));
				                              fn.pfn = &m_PubFuncTable->m_FuncTable[index];
				                              fn.nType = 1;                           
				                      }
				
				                                                ;
# line 1522 "cs.atg"
				FunctionCall(&fn);
# line 1523 "cs.atg"
				};
				break;
			case PointSym:  
# line 1524 "cs.atg"
				Get();
# line 1524 "cs.atg"
				Expect(identifierSym);
# line 1525 "cs.atg"
				
				{
				char* member = GetCurrSym();
				int address = m_pMainFunction->AddStaticData(strlen(member)+1, (BYTE*)member);
				//add command
				long op1, type1;
				TYPEDES dt1;
				
				//pop
				if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 != dtGeneral){
				         GENERR(96);
				        return;
				}else
				            {
				                 long temp = AllocTempVar(dtGeneral);
				             if (temp == -1)
				                     {
				 GENERR(98);
				                    }
				                    // get effective address for object member
				                    ADDCOMMAND3(__eaobj, AMODE_OBJ|AMODE_MEM<<8, temp, op1, address);
				                     _typedes(DT1, dtLong)
				                     m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
				            }
				            };
				break;
			case MinusGreaterSym:  
# line 1554 "cs.atg"
				{int state = 0;
# line 1554 "cs.atg"
				Get();
# line 1554 "cs.atg"
				while (Sym == LbraceSym) {
# line 1554 "cs.atg"
					Get();
# line 1554 "cs.atg"
					state++;
				}
# line 1554 "cs.atg"
				Expect(identifierSym);
# line 1554 "cs.atg"
				while (Sym == RbraceSym) {
# line 1554 "cs.atg"
					Get();
# line 1554 "cs.atg"
					state++;
				}
# line 1555 "cs.atg"
				
				              if (state == 0)         {                               
				                              //pop
				                              TYPEDES dt;
				                              long type;
				                              long op;
				                              if (!m_pMainFunction->PopDigit(&op, &type, &dt))
				                              {
				                                      GENERR(96);
				                              }
				                              else
				                              {
				                                      if (dt.objID > 0)
				                                      {
				                                              char szName[MAX_IDENTIFIER_LENGTH];
				                                              memset(szName, 0, MAX_IDENTIFIER_LENGTH);
				                                              Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称                             
				                                              
				                                              #if 0
				                                              //get offset
				                                              OBJMEMDES* pMember = this->m_ObjTable[dt.objID-1]->GetMemberByName(szName);
				                                              if (pMember == NULL)
				                                              {
				                                                      GENERR(121);                                    
				                                              }
				                                              else
				                                              {       
				                                                      TYPEDES dtTemp;
				                                                      memcpy(&dtTemp, &pMember->dt, sizeof(TYPEDES));
				                                                      
				                                                      long temp = AllocTempVar(dtLong, 1);
				                                                      
				                                                      if (temp == -1)
				                                                      {
				                                                              GENERR(98);
				                                                      }
				                                                      
				                                                      //add(op, offset) = address
				                                                      ADDCOMMAND2(__add, DC, op, pMember->offset)
				                                                      ADDCOMMAND2(__mov, DR, temp, _AX)
				                                                      if ((dtTemp.dim ==0 && dtTemp.objID == 0 )
				                                                              ||(dtTemp.objID > 0 && dtTemp.refLevel > 0))
				                                                              {//如果不是数组和obj
				                                                                      
				                                                                      //取改member的opsize
				                                                                      int opsize;
				                                                                      if (dtTemp.refLevel > 0) //如果是指针类型
				                                                                              opsize = log2(OPSIZE_PTR);
				                                                                      else
				                                                                              opsize = log2(typesize(dtTemp.type, dtTemp.objID));
				                                                                      opsize &= 0x3;
				                                                                      m_pMainFunction->PushDigit(temp, AMODE_MEM|(opsize << 6)|0x10, dtTemp);
				                                                                      
				                                                              }
				                                                              else
				                                                              {
				                                                                      
				                                                                      //如果是数组或obj, 生成临时变量存放数组地址
				                                                                      if (dtTemp.dim != 0)
				                                                                      {                                                                       
				                                                                              /*居卫华2001-08-22修改
				                                                                              dtTemp.refLevel++;
				                                                                              dtTemp.dim--;
				                                                                              */
				                                                                              m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2(OPSIZE_PTR)<<6), dtTemp);
				                                                                      }
				                                                                      else
				                                                                      {
				                                                                              dtTemp.refLevel++;
				                                                                              m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2(OPSIZE_PTR)<<6), dtTemp);
				                                                                      }
				                                                              }
				                                                              
				                                              }
				                                              #endif
				                                      }
				                              }
				                      }
				                      } // int state
				                      ;
				break;
			case identifierSym:  
# line 1639 "cs.atg"
				Get();
				break;
			case PlusPlusSym:  
# line 1642 "cs.atg"
				Get();
# line 1644 "cs.atg"
				
				              {
				                              long op1;
				                              long type1;
				                              TYPEDES dt1;
				                              //pop出被加数
				                              if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
				                              {
				                                      //      REPORT_COMPILE_ERROR("POP UP FAILED");
				                                                              GENERR(96);
				                      return;
				
				                              }
				                              else
				                              {
				                                      if (dt1.type == dtFloat)
				                                      {
				                                              GENERR(112);
				                                      }
				                                      else
				                                      {
				                                              //get address mode
				                                              int address_mode = (type1<<8);
				                                              address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);     
				                                              if (dt1.dim >0)
				                                              {//如果是数组变量
				                                                      //得到增量
				                                                      int size = UnitSize(dt1);
				                                                      for (int i=1; i<dt1.dim;i++)
				                                                      {
				                                                              size *= dt1.dimsize[i];
				                                                      }
				                                                      //加法
				                                                      ADDCOMMAND2(__add, (type1<<8)|0x80, op1, size)
				                                              }
				                                              else
				                                              {
				                                                      //add commmand to command table
				                                                      ADDCOMMAND2(__add, address_mode, op1, 1)        
				                                              }       
				                                              ADDCOMMAND2(__mov, address_mode|0x02, op1, _AX); 
				                                              //将AX中的结果存入临时变量
				                                              m_pMainFunction->PushDigit(op1, type1, dt1);
				                                      }
				                              }
				                      }
				              ;
				break;
			case MinusMinusSym:  
# line 1692 "cs.atg"
				Get();
# line 1694 "cs.atg"
				
				                      {
				                              long op1;
				                              long type1;
				                              TYPEDES dt1;
				                              //pop出被加数
				                              if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
				                              {
				                                      //      REPORT_COMPILE_ERROR("POP UP FAILED");
				                                                              GENERR(96);
				                      return;
				
				                              }
				                              else
				                              {
				                                      if (dt1.type == dtFloat)
				                                      {
				                                              GENERR(112);
				                                      }
				                                      else
				                                      {
				                                              //get address mode
				                                              int address_mode = (type1<<8);
				                                              address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);     
				                                              if (dt1.dim >0)
				                                              {//如果是数组变量
				                                                      //得到增量
				                                                      int size = UnitSize(dt1);
				                                                      for (int i=1; i<dt1.dim;i++)
				                                                      {
				                                                              size *= dt1.dimsize[i];
				                                                      }
				                                                      //加法
				                                                      ADDCOMMAND2(__sub, (type1<<8)|0x80, op1, size)
				                                              }
				                                              else
				                                              {
				                                                      //add commmand to command table
				                                                      ADDCOMMAND2(__sub, address_mode, op1, 1)        
				                                              }       
				                                              ADDCOMMAND2(__mov, address_mode|0x02, op1, _AX); 
				                                              //将AX中的结果存入临时变量
				                                              m_pMainFunction->PushDigit(op1, type1, dt1);
				                                      }
				                              }
				                      };
				break;
			default :GenError(105); break;
		}
	}
}

# line 2137 "cs.atg"
void cParser::UnaryOperator()
{
# line 2137 "cs.atg"
	switch (Sym) {
		case PlusSym:  
# line 2137 "cs.atg"
			Get();
			break;
		case MinusSym:  
# line 2137 "cs.atg"
			Get();
			break;
		case StarSym:  
# line 2137 "cs.atg"
			Get();
			break;
		case BangSym:  
# line 2137 "cs.atg"
			Get();
			break;
		case AndSym:  
# line 2137 "cs.atg"
			Get();
			break;
		case TildeSym:  
# line 2137 "cs.atg"
			Get();
			break;
		default :GenError(106); break;
	}
}

# line 1795 "cs.atg"
void cParser::Primary()
{
# line 1796 "cs.atg"
	
	      char szName[MAX_IDENTIFIER_LENGTH];
	      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
# line 1899 "cs.atg"
	switch (Sym) {
		case identifierSym:  
# line 1800 "cs.atg"
			Get();
# line 1800 "cs.atg"
			
			
			  {       Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
			  
			          
			          int address = -1;
			/*              
			          bool bThis = false;     
			          if (strcmp(szName, "this")==0){
			          // check whether this is a class method
			                  if (m_pCurClassDes){
			                          bThis = true;
			                          address = 0;
			                  }else{
			                          GENERR(127);
			                  }
			          }else
			              address = GetSymAddress(szName); // return -1 if not found
			  */
			          address = GetSymAddress(szName);
			          printf("address=%x", address);  
			
			           //如果address<0是函数名
			                    if (address >= 0 )//如果不是函数名， 是变量名。
			                    {
			                            TYPEDES dt;
			                            SYMBOLTABLEELE *pElement = m_pMainFunction->m_SymbolTable.GetSym(szName);
			                            if (pElement == NULL)
			                            {
			                                                            printf("===>generror 115, symbol name=%s", szName);
			                                    GENERR(115); // not found it symbol table, check it in runtime
			                            }
			                            else
			                            {
			                                    memcpy(&dt ,&(pElement->type), sizeof(TYPEDES));
			                                    /*if (pdt == NULL)
			                                    {
			                                    GENERR(111);
			                                    }
			                                    else*/
			                            
			                                    if ((dt.dim ==0 && dt.objID == 0 )
			                                            ||(dt.objID > 0 && dt.refLevel > 0))
			                                    {//如果不是数组和obj
			                                            int opsize;
			                                            if (dt.refLevel > 0) 
			                                                    opsize = log2((int)OPSIZE_PTR);
			                                            else
			                                                    opsize = log2((int)typesize(dt.type, dt.objID));
			                                            opsize &= 0x3;
			                                            m_pMainFunction->PushDigit(address, AMODE_MEM|(opsize << 6), dt);
			                                    }
			                                    else
			                                    {//如果是数组或obj, 生成临时变量存放数组地址
			                                            if (dt.dim != 0)
			                                            {
			                                                    long temp = AllocTempVar(dtLong, 1);
			                                                    if (temp == -1)
			                                                    {
			                                                            GENERR(98);
			                                                    }
			                                                    
			                                                    ADDCOMMAND2(__ea, DD, temp, address)
			                                                    /*居卫华2001－8－22修改
			                                                    dt.refLevel++;
			                                                    dt.dim--;
			                                                    */
			                                                    m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2( (int)(OPSIZE_PTR) )<<6), dt);
			                                            }
			                                            else // if it is object
			                                            {
			                                                                                    int opsize;
			                                                                                    opsize = log2((int)OPSIZE_PTR);
			                                                opsize &= 0x3;
			                                                                                    m_pMainFunction->PushDigit(address, AMODE_MEM|(opsize << 6), dt);
			                                            }
			                                    }
			                                    
			                            }
			                    }
			          else // address < 0, not found in symbol table
			          {
			                  //GENERR(126);
			                  if (this->m_PubFuncTable->FindFuncByName(szName) < 0) // not found in pub function table
			                  {
			                          // find it in class methods
			                          long index = 0;
			                          if (m_pCurClassDes->getFuncTable()->GetFunction(szName, &index) == NULL){ // not found in class function table
			                                  // create an object variable ?
			                                  GENERR(104);
			                          } 
			
			                          else
			                                  m_pCurClassDes->getFuncTable()->ReleaseFunc();
			                  }
			                  //      return;
			          }
			};
			break;
		case newSym:  
# line 1899 "cs.atg"
			Get();
# line 1899 "cs.atg"
			Creator();
			break;
		case stringD1Sym:  
# line 1902 "cs.atg"
			Get();
# line 1903 "cs.atg"
			
			             {
			                                        char* pCh;
			                                        pCh = new char[Scanner->CurrSym.Len+1];
			                                        if (pCh == NULL)
			                                        {
			                                                GENERR(106);
			                                                Get();
			                                                break;
			                                        }
			                                        memset(pCh, 0, Scanner->CurrSym.Len+1);
			                                                            Scanner->GetName(&Scanner->CurrSym, pCh, Scanner->CurrSym.Len);//得到名称
			                                           char* string = NULL;
			                                        string = AnalyzeConstString(pCh);
			                                     if (string == NULL)
			                                        {
			                                                if (pCh)
			                                                        delete pCh;
			                                                GENERR(100);                          
			                                                Get();
			                                                break;
			                                        }
			                    
			                                        int straddress = this->m_pMainFunction->m_nSSUsedSize;
			                                        if (m_pMainFunction->AddStaticData(strlen(string)+1, (BYTE*)string)>=0)
			                                        {       
			                                                _typedes(dt, dtStr)
			                                                
			                                                if (m_pMainFunction->AddVal(NULL,  dt))
			                                                {
			                                                        long temp;
			                                                        temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
			                                                        ADDCOMMAND2(__ea, DS, temp, straddress);
			                                                        m_pMainFunction->PushDigit(temp, AMODE_MEM, dt);                         
			                                                }
			                                        }
			                                        else
			                                        {
			                                                this->GENERR(98);
			                                        }
			                                            
			                                                            if (string)
			                                                delete string;
			                                                            if (pCh)
			                                                delete pCh;         
			                                };
			break;
		case charD1Sym:  
# line 1949 "cs.atg"
			Get();
# line 1950 "cs.atg"
			
			            {
			                    Scanner->GetName(&Scanner->NextSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
			                    _typedes(dt,dtChar);
			                    m_pMainFunction->PushDigit(szName[1], AMODE_DIRECT, dt);
			            }
			;
			break;
		case numberSym:  
# line 1958 "cs.atg"
			Get();
# line 1959 "cs.atg"
			
			
			             if (strchr(szName, '.'))        // float
			             {
			                     
			                     float number = (float)atof(GetCurrSym());
			                     _typedes(dt, dtFloat);                  
			                     m_pMainFunction->PushDigit(*(long*)&number, AMODE_DIRECT|OPSIZE_4B, dt);
			             }
			             else    // int
			             {
			                     
			                     int number = atoi(GetCurrSym());
			                     _typedes(dt, dtLong);                   
			                     // Address mode: direct, Operation=4Byte =>0x80
			                     m_pMainFunction->PushDigit(number, AMODE_DIRECT|OPSIZE_4B, dt);
			             }
			;
			break;
		case LparenSym:  
# line 1978 "cs.atg"
			Get();
# line 1978 "cs.atg"
			Expression();
# line 1978 "cs.atg"
			Expect(RparenSym);
			break;
		case LbraceSym:  
# line 1979 "cs.atg"
			SetDef();
			break;
		default :GenError(107); break;
	}
}

# line 1982 "cs.atg"
void cParser::FunctionCall(FUNCCALL* pFuncEntry)
{
# line 1982 "cs.atg"
	Expect(LparenSym);
# line 1983 "cs.atg"
	
	     // if this is object instance method, attach "this" fist.
	     ;
# line 1989 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym == newSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 1989 "cs.atg"
		ActualParameters(pFuncEntry);
	}
# line 1989 "cs.atg"
	Expect(RparenSym);
# line 1990 "cs.atg"
	
	//long lParamNum = 0;
	    if (pFuncEntry->nType) // public function
	    {
	            //addcommand
	            ADDCOMMAND0(__endcallpub);
	            //save return value
	            _typedes(dt, dtLong)
	            if (m_pMainFunction->AddVal(NULL, dt))
	            {                       
	                    long temp;
	                    temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                    ADDCOMMAND2(__mov, DR, temp , _AX);
	                    m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt);
	            }
	            else
	            {
	                    GENERR(98);
	            }
	                            
	    }
	    else // virtual function
	    {
	    // check param number
	    //if (lParamNum != pFuncEntry->pVF->m_iParamNum)
	    //{
	    //      GENERR(123);
	    //}
	
	    //addcommand
	    ADDCOMMAND0(__endcallv);
	
	    //save return value
	    _typedes(dt, dtLong)
	    if (m_pMainFunction->AddVal(NULL, dt))
	    {
	            long temp;
	            temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	            ADDCOMMAND2(__mov, DR, temp , _AX);
	            m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt);
	    }
	    else
	    {
	            this->GENERR(98);
	    }
	    };
}

# line 1743 "cs.atg"
void cParser::HashItem()
{
# line 1743 "cs.atg"
	if (Sym == stringD1Sym) {
# line 1743 "cs.atg"
		Get();
	} else if (Sym == identifierSym) {
# line 1743 "cs.atg"
		Get();
	} else GenError(108);
# line 1743 "cs.atg"
	Expect(ColonSym);
# line 1743 "cs.atg"
	Expression();
}

# line 1744 "cs.atg"
void cParser::SetItem()
{
# line 1744 "cs.atg"
	if (Sym == identifierSym ||
	    Sym == stringD1Sym) {
# line 1744 "cs.atg"
		HashItem();
	} else if (Sym == numberSym ||
	           Sym == charD1Sym ||
	           Sym == LbraceSym ||
	           Sym == LparenSym ||
	           Sym == StarSym ||
	           Sym == AndSym ||
	           Sym >= PlusSym && Sym <= MinusSym ||
	           Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	           Sym == newSym ||
	           Sym >= BangSym && Sym <= TildeSym) {
# line 1744 "cs.atg"
		Expression();
	} else GenError(109);
}

# line 1745 "cs.atg"
void cParser::SetItems()
{
# line 1745 "cs.atg"
	SetItem();
# line 1745 "cs.atg"
	while (Sym == CommaSym) {
# line 1745 "cs.atg"
		Get();
# line 1745 "cs.atg"
		SetItem();
	}
}

# line 1746 "cs.atg"
void cParser::SetDef()
{
# line 1746 "cs.atg"
	Expect(LbraceSym);
# line 1746 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym == newSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 1746 "cs.atg"
		SetItems();
	}
# line 1746 "cs.atg"
	Expect(RbraceSym);
}

# line 1748 "cs.atg"
void cParser::Creator()
{
# line 1749 "cs.atg"
	char szName[_MAX_PATH] = "";
# line 1750 "cs.atg"
	ClassFullName(szName);
# line 1750 "cs.atg"
	while (Sym == LparenSym) {
# line 1750 "cs.atg"
		Get();
# line 1750 "cs.atg"
		while (Sym >= varSym && Sym <= stringSym) {
# line 1750 "cs.atg"
			FormalParamList();
		}
# line 1750 "cs.atg"
		Expect(RparenSym);
	}
# line 1751 "cs.atg"
	        
	   CClassDes* cd = this->m_classTable->getClass(szName);
	   if (cd == NULL){
	           std::string s = JUJU::getFilePath(c->getCurSrcFile())+szName;
	           strcpy(szName, s.c_str());
	           cd = this->m_classTable->getClass(szName);
	           if (cd == NULL){
	                           strcat(szName, SCRIPT_EXT);
	                           CCompiler cc;                         
	               cc.Compile(szName);
	       }
	           // TODO generete correct error
	           //GENERR(100);
	           //return;
	   }
	           int address = m_pMainFunction->AddStaticData(strlen(szName)+1, (BYTE*)szName);
	   ADDCOMMAND1(__newobj,DS, address);
	   
	
	TYPEDES dt1;
	   memset(&dt1, 0, sizeof(TYPEDES));
	   dt1.type = dtGeneral;
	// 将AX中的结果存入临时变量
	   if (m_pMainFunction->AddVal(NULL,  dt1))
	   {                       
	                   long temp;
	                   long opsize = log2(UnitSize(dt1))<<6;
	                   temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                   ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp , _AX);
	                   m_pMainFunction->PushDigit(temp, AMODE_MEM|opsize, dt1);
	   }
	   else
	   {
	                   REPORT_COMPILE_ERROR("add symbol failed");
	   };
}

# line 2038 "cs.atg"
void cParser::ActualParameters(FUNCCALL* pFuncEntry)
{
# line 2039 "cs.atg"
	
	//      lParamNum = 0;
	    if (pFuncEntry == NULL)
	            return;
	
	    char cParamNum = 0;     
	
# line 2046 "cs.atg"
	Expression();
# line 2047 "cs.atg"
	
	    //pop
	    long op1;
	    long type;
	    TYPEDES dt1;
	    if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE )
	    {
	    //      REPORT_COMPILE_ERROR("POP UP FAILED");
	            this->GENERR(96);
	            return;
	    }
	    // address mode of dest op is in hight byte
	    int address_mode = (type<<8)&0xff00;
	    // set op number size
	    address_mode |= (log2(UnitSize(dt1))<<14);
	
	    if (pFuncEntry->nType)  // native function
	            ADDCOMMAND1(__parampub, address_mode, op1)                      
	    else
	            ADDCOMMAND1(__paramv, address_mode, op1)
	
	    cParamNum++; 
# line 2070 "cs.atg"
	while (Sym == CommaSym) {
# line 2070 "cs.atg"
		Get();
# line 2070 "cs.atg"
		Expression();
# line 2072 "cs.atg"
		
		                    // modified on 20030331 by weihua ju
		//                      if (cParamNum > pFuncEntry->params.size()-1)
		//                      {
		//                              GENERR(106);
		//                      }
		
		                    //pop
		                    long op1;
		                    long type;
		                    TYPEDES dt1;
		                    if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE)
		                    {
		                            //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                            GENERR(96);
		                            return;
		                    }
		                    else
		                    {
		                            //get address mode
		                            int address_mode = (type<<8)&0xff00;
		                            address_mode |= (log2(UnitSize(dt1))<<14);
		                            
		                            /*              保留
		                            if (dt1.dim > 0)
		                            {
		                            _typedes(dt, dtInt)
		                            long temp;
		                            //如果是数组, 把它的地址存入临时变量, 传入临时变量
		                            if (m_pMainFunction->AddVal(NULL, dt))
		                            {                       
		                            temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
		                            ADDCOMMAND2(__ea, DD, temp, op1);
		                            }
		                            long size = sizeof(long*);
		                            size = log2(size);
		                            size = size << 14;
		
		                            ADDCOMMAND1(__parampub, size|0x100, temp)       
		                            }
		                            else    
		                            */                      
		                            if (pFuncEntry->nType)  // native function
		                            ADDCOMMAND1(__parampub, address_mode, op1)                      
		                                    else
		                            ADDCOMMAND1(__paramv, address_mode, op1)                
		                            cParamNum++; 
		                    }               
		;
	}
# line 2123 "cs.atg"
	
	            // code added on 20030331 weihua ju
	            if ((pFuncEntry->nType!=0) && cParamNum != pFuncEntry->pfn->cParamNum)
	            {
	
	                    GENERR(106);
	            }
	    //lParamNum = cParamNum;
}



void cParser::Parse()
{ Scanner->Reset(); Get();
  C();
}

//////////////////////////////////
// add by jackie juju

// all these function maybe should be move to single class
BOOL cParser::AllocVar(PTYPEDES type, char *szName)
{
	/*int size_t = 0;
	//get size 
	if (nType < 0)
	{
		size_t = sizeof(long);
	}
	else
	{
		switch(nType)
		{
		case dtShort:
			size_t = 1;
			break;

		case dtInt:
			size_t = 2;
			break;
		case dtLong:
			size_t = 4;
			break;
		case dtChar:
			size_t = 1;
			break;
		case dtString:
			size_t = 4;
			break;
		case dtStrArray:
			size_t = 4;
			break;
		default:
			REPORT_COMPILE_ERROR("undefined type");
			return -1;
		}
	}
*/

	if (m_pMainFunction) // in function definition
		return m_pMainFunction->AddVal(szName, *type);
	else
		return this->m_pCurClassDes->AddMember(szName, *type);

}



BOOL cParser::PopOp(int *op)
{
	if (op == NULL)
		return FALSE;
	*op = 0;
	if (this->m_pExpOpPt->pPrev == NULL)
		return FALSE;
	*op  = m_pExpOpPt->opcode;
	EXPRESSIONOP *pTemp = m_pExpOpPt;
	m_pExpOpPt = m_pExpOpPt->pPrev;
	delete pTemp;
	return TRUE;
}


/*
   函数名称     : cParser::PushExpOp
   函数功能	    : 一元运算符入栈
   变量说明     : 
   int op: 运算符
   返回值       : 
   编写人       : 居卫华
   完成日期     : 2001 - 6 - 6
*/
void cParser::PushExpOp(int op)
{
	EXPRESSIONOP *pNew = new EXPRESSIONOP;	
	if (pNew == NULL)
	{
		REPORT_MEM_ERROR("memory allocation error");
		return;
	}

	pNew->opcode = op;
	pNew->pPrev = m_pExpOpPt;
	m_pExpOpPt = pNew;
}
/*

void cParser::PushExpOp2(int op)
{
	EXPRESSIONOP *pNew = new EXPRESSIONOP;	
	pNew->opcode = op;
	pNew->pPrev = m_pExpOpPt2;
	m_pExpOpPt2 = pNew;
}

void cParser::PushExpDigit2(long digit, int type)
{
	EXPRESSIONDIGIT *pNew = new EXPRESSIONDIGIT;	
	pNew->digit = digit;
	pNew->type = type;
	pNew->pPrev = this->m_pExpDigitPt2;

	m_pExpDigitPt2 = pNew;
}

BOOL cParser::PopOp2(int *op)
{
	if (this->m_pExpOpPt2->pPrev == NULL)
		return FALSE;
	*op  = m_pExpOpPt2->opcode;
	EXPRESSIONOP *pTemp = m_pExpOpPt2;
	m_pExpOpPt2 = m_pExpOpPt2->pPrev;
	delete pTemp;
	return TRUE;
}

BOOL cParser::PopDigit2(long *digit, int *type)
{
	if (this->m_pExpDigitPt2->pPrev == NULL)
		return FALSE;
	*digit = m_pExpDigitPt2->digit;
	*type = m_pExpDigitPt2->type;
	EXPRESSIONDIGIT *pTemp = m_pExpDigitPt2;
	m_pExpDigitPt2 = m_pExpDigitPt2->pPrev;
	delete pTemp;
	return TRUE;
}

*/


void cParser::ClearOpStack()
{
	while (this->m_pExpOpPt->pPrev != NULL)
	{
		EXPRESSIONOP *pTemp = m_pExpOpPt;
		this->m_pExpOpPt = this->m_pExpOpPt->pPrev;
		delete pTemp;
	}
	m_pExpOpPt = &m_ExpOp;
}

int cParser::GetSymAddress(char *szName)
{
	return this->m_pMainFunction->GetSymbolAddress(szName);
}


void cParser::AddNewLoop()
{
	CLoopTree *pNew = new CLoopTree(m_pMainFunction);

	m_curloop->AddNew(*pNew);

	this->m_curloop = pNew;
}

void cParser::ExitCurLoop()
{
	this->m_curloop = m_curloop->m_parent;
	m_curloop->RemoveChild();

}

void cParser::SetPubFuncTable(CPubFuncTable *pTable)
{
	this->m_PubFuncTable = pTable;
}



BOOL cParser::AllocArrayVar(PTYPEDES type, char *szName, int size)
{
	if (!m_pMainFunction->AddVal(szName, *type))
		return FALSE;
	//if (!m_pMainFunction->AddVal(NULL, type->size_t*size, type->type)||!m_pMainFunction->AddVal(szName, typesize(dtInt), dtInt))
	//	return FALSE;
	
	return TRUE;
}

char* cParser::AnalyzeConstString(char *string)
{
	int size = 0;
	int len = strlen(string);
	if (len == 0)
		return NULL;

	char *p = string;
	char *newstring = new char[len+1];
	memset(newstring, 0, sizeof(char)*(len+1));

	p++;//"
	while(*p != '"' && size<=len)
	{
		while (*p != '\\' && *p != '"' && size<=len)
		{
			newstring[size] = *p;
			p++;
			size++;
		}
		if (size >= len)
			break;
		if (*p == '\\')
		{
			p++;
			switch (*p)
			{
				case '\\': newstring[size] = '\\'; break;
				case 'r':newstring[size] = 0x0d; break;
				case 'n':newstring[size] = 0x0a; break;
				case 't':newstring[size] = '\t'; break;
				default: 
					//	newstring[size] = '\\'; 
					//	size++;
					//	newstring[size] = 't';				
					GENERR(124);
					break;
			}
			p++;
			size++;
		}
		else
			break;
	}
	newstring[size] = 0;
	size++;
	return newstring;

}





int cParser::UnitSize(TYPEDES &type)
{
	if (type.refLevel<=0)
		return typesize(type.type, type.objID);
	else
		return sizeof(long*);
}



/*
函数名称     : cParser::NeedCast
函数功能	    : 判断是否需要类型转换, 并返回转换码和要转换的运算数
变量说明     : 
TYPEDES dt1 : 运算数1
TYPEDES dt2 : 运算数2
char &casted : [OUT]要被转换的运算数 
返回值       : 要进行的类型转换代号, -1表示不需要转换
编写人       : 居卫华
完成日期     : 2001 - 6 - 8
*/
long cParser::NeedCast(TYPEDES dt1, TYPEDES dt2, char &casted)
{
	casted = 0;
	TYPEDES DT1, DT2;
	//beckup
	memcpy(&DT1, &dt1, sizeof(TYPEDES));
	memcpy(&DT2, &dt2, sizeof(TYPEDES));

	/*
	//如果是指针, 则不能进行转换
	if (DT1.refLevel > 0 || DT2.refLevel > 0)
		return -1;

*/
	if ((DT1.objID > 0 && DT2.objID == 0 ) || (DT2.objID > 0 && DT1.objID == 0 ))
	{
		return -1;
	}
	//指针都转换成long
	if (DT1.refLevel > 0)
	{
		//指针不能同浮点进行运算 
		if (dt2.type ==dtFloat)
		{
			return -1;
		}
		dt1.type = dtLong;
		dt1.refLevel = 0;
	}

	if (DT2.refLevel > 0)
	{
		//指针不能同浮点进行运算 
		if (DT1.type == dtFloat)
		{
			return -1;
		}
		DT2.type = dtLong;
		DT2.refLevel = 0;
	}


	///////////////////////////////
	// code modify 2002-03-19
	///////////////////////////////
/*	
	original code:
	//如果类型相同, 不需要转换
	if (DT1.type == DT2.type)
		return -1;


	switch (DT1.type)
	{
	case dtFloat:
		{
			casted = 2;
			switch (DT2.type)
			{
			case dtChar: return __CAST_C2F;
			case dtShort: return __CAST_S2F;
			case dtInt: return __CAST_I2F;
			case dtLong: return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtLong:
		{
			switch (DT2.type)
			{
			case dtChar: casted = 2; return __CAST_C2L;
			case dtShort: casted = 2; return __CAST_S2L;
			case dtInt: return -1;
			case dtFloat: casted = 1; return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtInt:
		{
			switch (DT2.type)
			{
			case dtChar: casted = 2; return __CAST_C2I;
			case dtShort: casted = 2; return __CAST_S2I;
			case dtLong: return -1;
			case dtFloat: casted = 1; return __CAST_I2F;
			default:GENERR(110);return -1;
			}
		}
	case dtShort:
		{
			switch (DT2.type)
			{
			case dtChar: casted = 2; return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_S2I;
			case dtLong: casted = 1;  return __CAST_S2L;
			case dtFloat: casted = 1; return __CAST_S2F;
			default:GENERR(110);return -1;
			}
		}
	case dtChar:
		{
			switch (DT2.type)
			{
			case dtShort: casted = 1;return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_C2I;
			case dtLong: casted = 1;  return __CAST_C2L;
			case dtFloat: casted = 1; return __CAST_C2F;
			default:GENERR(110);return -1;
			}
		}
	default:GENERR(110);		
	}
*/
	/* new code:*/
	if (dt1.type == dt2.type)
		return -1;

	switch (dt1.type)
	{
	case dtFloat:
		{
			casted = 2;
			switch (dt2.type)
			{
			case dtChar: return __CAST_C2F;
			case dtShort: return __CAST_S2F;
			case dtInt: return __CAST_I2F;
			case dtLong: return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtLong:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2L;
			case dtShort: casted = 2; return __CAST_S2L;
			case dtInt: return -1;
			case dtFloat: casted = 1; return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtInt:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2I;
			case dtShort: casted = 2; return __CAST_S2I;
			case dtLong: return -1;
			case dtFloat: casted = 1; return __CAST_I2F;
			default:GENERR(110);return -1;
			}
		}
	case dtShort:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_S2I;
			case dtLong: casted = 1;  return __CAST_S2L;
			case dtFloat: casted = 1; return __CAST_S2F;
			default:GENERR(110);return -1;
			}
		}
	case dtChar:
		{
			switch (dt2.type)
			{
			case dtShort: casted = 1;return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_C2I;
			case dtLong: casted = 1;  return __CAST_C2L;
			case dtFloat: casted = 1; return __CAST_C2F;
			default:GENERR(110);return -1;
			}
		}
	case 0:// 空操作数(dummy type)
		return -1;
	default:GENERR(110);		
	}
	/* new code end.*/
///////////////////////////////
// code modify end. 2002-03-19 
///////////////////////////////

	GENERR(110);
	return -1;
}


/*
   函数名称     : cParser::AllocTempVar
   函数功能	    : 分配一个临时变量
   变量说明     : 
   long type	: 变量的类型
   返回值       : 变量的地址, -1 表示失败
   编写人       : 居卫华
   完成日期     : 2001 - 6 - 8
*/
long cParser::AllocTempVar(long type, long reflevel)
{
	_typedes(dt1, type)
	dt1.refLevel = reflevel;

	long temp;
	if (m_pMainFunction->AddVal(NULL,  dt1))
	{			
		temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;		
		return temp;
	}
	else
		return -1;				
}

/*
   函数名称     : cParser::Cast
   函数功能	    : 自动类型转换
   变量说明     : 
   返回值       : 
   编写人       : 居卫华
   完成日期     : 2001 - 6 - 11
*/
void cParser::Cast(long &op1, long &type1, TYPEDES &dt1, long &op2, long &type2, TYPEDES &dt2)
{
			long castcode = -1; //cast操作码
			char casted = 0;	//被转换类型的运算数
			castcode = NeedCast(dt1, dt2, casted);
			if (castcode != -1)
			{
				//类型转换
				long temp;//临时变量地址, 存放转换后的变量
				long type;//目标类型
				long am;  //cast指令的寻址方式
				long* castedop = NULL;
				if (casted == 1)
				{
					type = dt2.type;
					castedop = &op1;
				}
				if (casted == 2)
				{
					type = dt1.type;
					castedop = &op2;
				}
				temp = AllocTempVar(type);
				if (temp == -1)
				{
					GENERR(98);
				}
				else
				{
					am = 1 | (log2((int)(typesize(type, 0))<<6));
					am = am << 8;//temp的寻址方式
					if (casted == 1)
					{			
						long exchange = am>>8;						
						am |= (type1&0x00ff) /*| (((type2&0x30)<<8)&0xff00)*/;//整条指令的寻址方式
					ADDCOMMAND3(__cast, am, temp, *castedop, castcode)
						//修改运算数
						op1 = temp;
						type1 = exchange;
						dt1.type = type;
					}
					if (casted == 2)
					{
						long exchange = am >> 8;
						am |= (type2&0xff) /*| (((type1&0x30)<<8)&0xff00)*/;//整条指令的寻址方式					
					ADDCOMMAND3(__cast, am, temp, *castedop, castcode)
						//修改运算数
						op2 = temp;
						type2 = exchange;
						dt2.type = type;
					}
				}				
			}
}

BOOL cParser::AddClass(CClassDes& obj)
{
/*
	if (this->m_lClassDesNum == this->m_lClassDesTableSize)
	{
		CClassDes** pNewTable = NULL;

		pNewTable = new CClassDes*[m_lClassDesTableSize+50];
		if (pNewTable == NULL)
		{
			REPORT_MEM_ERROR("Memory allocation failed\r\n");
			return FALSE;
		}
		memcpy(pNewTable, this->m_classTable, sizeof(CClassDes*)*m_lClassDesNum);
		delete this->m_classTable;
		this->m_classTable = pNewTable;		
		m_lClassDesTableSize += 50;
	}
	m_classTable[m_lClassDesNum] = &obj;
	this->m_lClassDesNum++;
    m_pCurClassDes = &obj;
	return TRUE;
*/
    m_classTable->addClass(&obj);
	std::string msg = "add classes";
	debug(msg);
    return TRUE;

    return TRUE;

}
/*
long cParser::GetClassIdByName(char *szName)
{	

	int i;
	char * name;
	for (i = 0; i< m_lClassDesNum; i++)
	{
		name = (*m_classTable)[i]->GetFullName();
		if (!strcmp(name, szName))
			return i+1;
	}
	return 0;


}
	*/



void cParser::SetByteCodeFilePath(char* szPath)
{
	if (szPath == NULL)
		return;
	strcpy(m_szByteCodeFilePath, szPath);
	while (m_szByteCodeFilePath[strlen(m_szByteCodeFilePath) - 1] == PATH_SEPARATOR_C)
		m_szByteCodeFilePath[strlen(m_szByteCodeFilePath) - 1] = 0; 
}


cParser::cParser(CCompiler* c, AbsScanner *S, CRError *E) : CRParser(S,E)
{
	m_conf = NULL;
	
	m_LoopTree = new CLoopTree();

	m_pMainFunction = new CFunction;



	m_pExpOpPt = &m_ExpOp;
	m_ExpOp.pPrev = NULL; 


	m_curloop  = m_LoopTree;

	m_classTable = NULL;
	m_lClassDesNum = 0;
	m_lClassDesTableSize = 0;

	m_szByteCodeFilePath[0] = 0;
    m_pCurClassDes = NULL;
    memset(curFileName, 0, _MAX_PATH);

    this->c = c;
}

cParser::~cParser()
{

	/*if (this->m_classTable)
	{
		for (int i= 0; i < this->m_lClassDesNum; i++)
		{
			if (m_classTable[i])
				delete m_classTable[i];
		}
		delete m_classTable;
	}*/

	SAFEDELETE(m_LoopTree);
    SAFEDELETE(m_pMainFunction);
}


bool cParser::doMove(long type1, long type2, long op1, long op2, TYPEDES& dt1, TYPEDES& dt2 )
{

	//get address mode
	int address_mode = (type1<<8)|(short)type2;
	address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);

	if (dt1.type != dtGeneral && dt2.type != dtGeneral){

		//add commmand to command table
		ADDCOMMAND2(__mov, address_mode, op1, op2)      
		pushResultAX();
	}
	else{
		if (dt2.type == dtGeneral && dt1.type != dtGeneral) // can not assign object to primitive type
			this->GENERR(11); // TODO
		//add commmand to command table
		ADDCOMMAND3(__movobj, address_mode, op1, op2, dt2.type)      
		m_pMainFunction->PushDigit(op1, AMODE_OBJ|0x80, dt1);
	}
	return true;
}


void cParser::doVarDecl(PTYPEDES type, char* szFirstName)
{
     long op;
	      long type1;
	      TYPEDES DT1;
	      if (!m_pMainFunction->PopDigit(&op, &type1, &DT1))
	      {
	              if (!AllocVar(type, szFirstName))
	                      GENERR(113);
				  else{
					  long temp =  m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
					  m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, *type);
				  }
	      }
	      else
	      { 
	              if (type1 >=FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE)
	              {
	                      //error
	              };
	              /*              int i;
	              BOOL bPop = TRUE;
	              while (!bPop)
	              {       
	              if (type1 != AMODE_DIRECT)
	              {
	              //error
	              }
	              for ( i= 0; i<op; i++0)
	              {
	              AllocVar(type, NULL);
	              }
	              bPop = m_pMainFunction->PopDigit(&op, type1);
	              }
	              */      

	              int dimsize[64];//数组最大维数64
	              int i = 0;
	              int arraysize = op;//total size
	              dimsize[i] = op;
	              i++;

	              while (m_pMainFunction->PopDigit(&op, &type1, &DT1))
	              {
	                      dimsize[i] = op;                        
	                      i++;
	                      arraysize *= op;
	              }
	              type->dim = i;
	              int k,j;
	              k = 0;
	              for (j=i-1; j>=0; j--)
	              {
	                      type->dimsize[j] = dimsize[k];
	                      k++;
	              }

	              if (!AllocArrayVar(type, szFirstName, arraysize))
	                      GENERR(113);
				  else{
					  long temp =  m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
					  m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
				  }
	      }
}
void cParser::pushResultAX(){
	//push result
	TYPEDES dt;//无效
	memset(&dt, 0, sizeof(TYPEDES));
	this->m_pMainFunction->PushDigit(_AX, 0x82,dt);
}
bool cParser::doAssign()
{
    //add command
    long op1, op2;
    long type1, type2;
    TYPEDES dt1, dt2;

    //pop
    if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) 
    || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE 
    || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
    {
    //      REPORT_COMPILE_ERROR("POP UP FAILED");
            GENERR(96);
            return false;
    }
    else
    {
            //类型转换
            long castcode = -1; //cast操作码
            char casted = 0;        //被转换类型的运算数
            //类型转换
            long temp;//临时变量地址, 存放转换后的变量
            long type;//目标类型
            long level;
            long objid;
            long am;  //cast指令的寻址方式
            long* castedop = NULL;
            type = dt1.type;
            level = dt1.refLevel;
            castedop = &op2;
            objid = dt1.objID;
		    if (dt1.type != dtGeneral && dt2.type != dtGeneral) //get cast code
            {
                    TYPEDES DT1, DT2;
                    memcpy(&DT1, &dt1, sizeof(TYPEDES));
                    memcpy(&DT2, &dt2, sizeof(TYPEDES));
                    if ( (DT1.objID > 0 && DT2.objID ==0) || (DT2.objID > 0 && DT1.objID ==0))
                    {
                            GENERR(110);
                            return false;
                    }

                    if (DT1.refLevel > 0)//是指针
                    {
                            if (DT2.refLevel == 0 // 不是指针
                                    && DT2.type != dtLong //不是长整型
                                    && DT2.type != dtInt)
                            {
                                    GENERR(110);
                                    return false;
                            }
                            DT1.type = dtLong;                                      
                    }
                    if (DT2.refLevel > 0)
                    {
                            if (DT1.refLevel == 0 && DT1.type != dtLong &&DT1.type != dtInt)
                            {
                                    GENERR(110);
                                    return false;
                            }
                            DT2.type = dtLong;                                      
                    } 
                    switch (DT2.type)
                    {
                    case dtChar:
                            {
                                    switch (DT1.type)
                                    {
                                    case dtChar:break;
                                    case dtShort:castcode = __CAST_C2S;break;
                                    case dtInt:castcode = __CAST_C2I;break;
                                    case dtLong:castcode = __CAST_C2L;break;
                                    case dtFloat:castcode = __CAST_C2F;break;
                                    default:GENERR(110);return false;
                                    }                                               
                            }
                            break;
                    case dtShort:
                            {
                                    switch (DT1.type)
                                    {
                                    case dtChar:castcode = __CAST_S2C;break;
                                    case dtShort:break;
                                    case dtInt:castcode = __CAST_S2I;break;
                                    case dtLong:castcode = __CAST_S2L;break;
                                    case dtFloat:castcode = __CAST_S2F;break;
                                    default:GENERR(110);return false;
                                    }                                               
                            }
                            break;
                    case dtInt:
                     {
                                                switch (DT1.type)
                                                {
                                                case dtChar:castcode = __CAST_I2C;break;
                                                case dtShort:castcode = __CAST_I2S;break;                                                     
                                                case dtFloat:castcode = __CAST_I2F;break;
                                                case dtInt:
                                                case dtLong:
                                                                                            case dtStr:break; // not need to cast

                                                default:GENERR(110);return false;
                                                }                                               
                                        }
                            break;
                    case dtLong:
                            {
                                    switch (DT1.type)
                                    {
                                    case dtChar:castcode = __CAST_L2C;break;
                                    case dtShort:castcode = __CAST_L2S;break;
                                    case dtInt:break;
                                    case dtLong:break;
                                    case dtFloat:castcode = __CAST_L2F;break;
                                    default:GENERR(110);return false;
                                    }                                               
                            }
                            break;
                    case dtFloat:
                            if (DT1.type != dtFloat) 
                                    GENERR(110);
                            break;
                    } // switch
            } // if 
            temp = AllocTempVar(type, level);
            if (temp == -1)
            {
                    GENERR(98);
            }
            else if (castcode != -1)
            {//需要转换

                    am = 1 | (log2(UnitSize(dt1))<<6);
                    am = am << 8;//temp的寻址方式
                    long exchange = am >> 8;
                    am |= (type2&0xff) /*| (((type2&0x30)<<8)&0xff00)*/;//整条指令的寻址方式                                        
                    ADDCOMMAND3(__cast, am, temp, *castedop, castcode)
                    //修改运算数
                    type2 = exchange;
                    dt2.type = type;
                    op2 = temp;
            }                               

            doMove(type1, type2, op1, op2, dt1, dt2);

     } // else
    return true;

}
// add by jackie juju
//////////////////////////////////
