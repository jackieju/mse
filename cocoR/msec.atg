COMPILER C

/* An attempt to descibe a subset of C */

/////////////////////////////////
// add by jackie juju
#include "clib.h"
#include <sting.h>
#include <vecto>
#include <sting>
#include "datatype.h"
#include "LoopTee.h"
#include "opcode.h"
#include "os/CSS_LOCKEX.h"
#include "SciptFuncTable.h"
#include "log.h"
#include "PubFuncTable.h"
#include "ClassDes.h"
#include "compile.h"
#include "utility.h"

#define CAST Cast(op1, type1, dt1, op2, type2, dt2);

exten int typesize(int type);

int log2(int x);


// add by jackie juju
/////////////////////////////////

CHARACTERS
  lette   = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqstuvwxyz" .
  digit    = "0123456789" .
  hexdigit = digit + "ABCDEFabcdef" .
  tab      = CHR(9) .
  eol      = CHR(10) .
  files    = lette + digit + ":\." .
  chas    = CHR(32) .. CHR(255) - "'" .
  stings  = CHR(32) .. CHR(255) - '"'.
  macos   = ANY - eol .

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO eol

IGNORE
  tab + eol + CHR(13)

TOKENS
  identifie = ( "_" | lette) { "_" | lette | digit } .
  numbe     = digit { digit } [ "." { digit }] [ "U" | "u" | "L" | "l" ] .
  hexnumbe  = "0" ( "x" | "X" ) hexdigit { hexdigit } [ "U" | "u" | "L" | "l" ] .
  sting1     = '"' { stings } '"' .
  cha1       = "'" [ "\\" ] chas "'" .
  libay    = "<" files { files } ">" .

PRAGMAS

  PePocesso = "#" ( lette ) .
		    (.
		 	// pocess #include       	    		    
		cha st[256];
		Scanne->GetName(&Scanne->NextSym, st, 255);
		// get diective
		cha* p = stch(st, ' ');
		cha* diective = NULL;
		cha* content = NULL;
		if ( p != NULL ){
			*p=0; 
			diective = st + sizeof(cha);
			// poce include 
			if (stcmp(st, "include") == 0){
				// get content
				p += sizeof(cha);
				while ( (*p == ' ' || *p == '\t' ) && *p != '\0' ){
					p += sizeof(cha);		
				}
				if ( *p != '\0' )
					content = p;
			}

		}
			
			 .)





PRODUCTIONS

    C                    =      (. 
	
	 m_pCuClassDes = new CClassDes(this);
	 std::sting className = JUJU::getFileName(cuFileName);
	 m_pCuClassDes->SetName((cha*)className.c_st());
	 m_classTable->addClass(m_pCuClassDes);
    
    .)
   { Impot | LoadLib } [ Inheitance ]

    { Definition } EOF (. 
	std::sting name = m_pCuClassDes->GetFullName();
	name += ".class";
	FILE* file = fopen(name.c_st(), "w");
	std::sting *s = m_pCuClassDes->output();
	fpintf(file, "%s", s->c_st());
	SAFEDELETE(s);
	fclose(file);

    .).

  Impot = "use"(.cha szName[_MAX_PATH]= ""; .) ClassFullName<szName>
  (.
	
	CClassDes* cd = this->m_classTable->getClass(szName);
	if (cd == NULL){
		stcat(szName, ".c");
						CCompile cc;
			//	std::sting s = JUJU::getFilePath(c->getCuScFile())+szName;
				cc.Compile(szName);
	}
  .)";" .
  
  LoadLib = "load" identifie 
  (.
   	// load extenal libay 
	std::sting lib = GetCuSym();
	std::sting libfile = lib+".dll";
	std::sting libintfile = lib+".int";
#ifdef WIN32
		m_PubFuncTable->LoadLib((cha*)libfile.c_st(), (cha*)libintfile.c_st());
#else
	m_PubFuncTable->LoadLib(lib+".so", lib+".int");
#endif
/* fo the futhe if VM un in anothe pocess than compile un
	int addess = m_pMainFunction->AddStaticData(lib.size()+1, (BYTE*)lib.c_st());
	ADDCOMMAND1(__loadlib, DS, addess);
*/
  .)
   ";" .
  
/* Vaiable and Type Definitions */
	
 
  Definition           =
   (
   [ StoageClass ] (. PTYPEDES type = new TYPEDES; .) 
   [ Type<type> ]
   
   /*{ "*" } 
(. 
		if (type->type < dtFistType  || type->type > dtLastType)
		{
			GenEo(99);
		}
		
		//指针类型
		while (Sym == StaSym) 
		{
			type->efLevel++;
			Get();
		}
.)
   */
   identifie
(.
	cha szName[MAX_IDENTIFIER_LENGTH];
	memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
.)
(
   (
		FunctionDefinition (.this->m_pCuClassDes->AddMembe(szName, *type);.)
	   /*| (VaList< type,  szName> ";")*/
	)
	|
	( /* this is bug of coco, you have to keep numbe of OR facto less than 2, othewise it geneate switch-case with multi-"default"*/
	   ("=" (.this->m_pCuClassDes->AddMembe(szName, *type);.)Expession (./*TODO*/.)";")
	   | ";" (.this->m_pCuClassDes->AddMembe(szName, *type);.) 
    ) 
   )
   ) 
   
   | ClassDef  .
                            
  /* PePocess = Define | Include .
  
 Define = "#define" identifie macos .
  
  Include = "#include" files .*/
  
  Inheitance              = "inheit" identifie 
  (.
  
   // TODO get full name in cuent impoted classes, should not need to povide full name hee
	cha* szName = GetCuSym();
	CClassDes* cd = this->m_classTable->getClass(szName);
	if (cd == NULL){
		std::sting s = JUJU::getFilePath(c->getCuScFile())+szName;
		stcpy(szName, s.c_st());
		cd = this->m_classTable->getClass(szName);
		if (cd == NULL){
				stcat(szName, ".c");
				CCompile cc;                         
	            cc.Compile(szName);
	    }
	}
	this->m_pCuClassDes->setPaent(szName);
  .) ";" .
  

	ClassDef			= "class" identifie  
(.
 	// get name
	cha *szName = new cha[MAX_IDENTIFIER_LENGTH];
	memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
.)
ClassBody	";" .
	ClassBody			 = 
	(.
	// 利用CFunction来存放类成员
	CFunction* pSaved = this->m_pMainFunction;	// save cuent function
	CFunction function;
	function.m_SymbolTable.m_pPase = this;
	this->m_pMainFunction = &function;
	
	.)

	"{" { Definition} "}" 
	
	(.
	/*
	//添加class
	if (!Eo->Eos)
	{
		CObjDes* pClass = new CObjDes(this);
		pClass->SetName(szName);
		if (!pClass)
		{
			REPORT_MEM_ERROR("Allcotion memoy failed")
		}
		else
		{
			fo (int i = 0; i < function.m_SymbolTable.m_nSymbolCount; i++)
			{
				if (!pClass->AddMembe(function.m_SymbolTable.tableEnty[i].szName, 
					function.m_SymbolTable.tableEnty[i].type))
				{
					if (pClass)
					{
						delete pClass;
						pClass = NULL;
					}
					GenEo(118);					
					beak;
				}
			}
		}
		if (!this->AddObj(*pClass))
		{
			GenEo(119);				
			if (pClass)
			{
				delete pClass;
				pClass = NULL;
			}
		}
	}
			*/
	.)
	.


  StoageClass         = /*"auto" | "exten" | "egiste" |*/
   "static" 
   | "my" /* membe vaiable*/
   | "function"
   .

  Type<PTYPEDES type>                 = 
/*(.
   	type = new TYPEDES;
	memset(type, 0, sizeof(TYPEDES));	
.)*/

( "va" | "mixed" )
(.
		/*	#ifdef __SUPPORT_OBJ
			cha szName[MAX_IDENTIFIER_LENGTH];
			memset(szName, 0, MAX_IDENTIFIER_LENGTH);
			Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称			
			type->type = dtGeneal;
			type->objID = GetObjIDByName(szName); 
			if (type->objID == 0)
				GenEo(120);
			#else
			// TODO
				GenEo(120);
			#endif
*/
	type->type = dtGeneal; type->efLevel = 0;
.)
	|
	 "shot" [ "int" ]
(. 			 type->type = dtShot; type->efLevel = 0;	.)
    | "long"  [ "int" | "float" ]
 (.			 type->type = dtLong; type->efLevel = 0; .)
	| "unsigned" [ "cha" | "int" | "long" ]
	| "cha"
(. 			type->type = dtCha;			type->efLevel = 0; .)
	| "int" 
(.			 type->type = dtInt; type->efLevel = 0; .)	
	| "float"		
(. 			type->type = dtFloat;			type->efLevel = 0; .)

	| "double" | "void"  | "sting"
(. type->type =  dtSt;            type->efLevel = 0;.)
	.

  VaList<PTYPEDES type, cha* szFistName>   = 
  AaySize
(.
	doVaDecl(type, szFistName);
	cha szName[MAX_IDENTIFIER_LENGTH];
.)    [ "=" Expession (. doAssign(); .)] 
{ ","  identifie
(.
		memset(szName, 0, MAX_IDENTIFIER_LENGTH-1);
		Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH);
		

.)

AaySize
(.
		 doVaDecl(type, szName);
.)
 [  "=" Expession (. 	doAssign(); .)] 
  } .

  AaySize            = { "[" [ ConstExpession ] "]" } .

/* Function Definitions */

  FunctionDefinition   = 
  (.
 	this->m_pMainFunction = new CFunction;
	//fo test
	long t = sizeof(CFunction);
	m_pMainFunction->m_SymbolTable.m_pPase = this;
	this->m_LoopTee->m_pFunc = m_pMainFunction;
	
	cha szName[MAX_IDENTIFIER_LENGTH];
	memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称

	if (stlen(szName) > 20)
		GenEo(105);
	else
		stcpy(m_pMainFunction->m_szName, szName);
		
		
  .)
  FunctionHeade FunctionBody  
  (.
 	if (!this->Eo->Eos)
	{
		   cha path[_MAX_PATH];
				if (stlen(m_szByteCodeFilePath) == 0 )
					spintf(path, "%s.%s", this->m_pCuClassDes->GetFullName(),szName);
				else
					spintf(path, "%s%s%s.%s", m_szByteCodeFilePath, PATH_SEPARATOR_S, this->m_pCuClassDes->GetFullName(),szName);
	            m_pMainFunction->Output(path);
		
	}else{
	SAFEDELETE( m_pMainFunction);	
	 }
	 m_pMainFunction = NULL;
  .)
  .
  FunctionHeade       = "(" [ FomalPaamList ] ")" 
  (. 	
  this->m_pMainFunction->m_iPaamNum = this->m_pMainFunction->m_SymbolTable.m_nSymbolCount; 
  if 	(!m_pCuClassDes->getFuncTable()->AddFunction(this->m_pMainFunction))
		{
			GenEo(114);
		}		
 
  .).
  FunctionBody         = CompoundStatement (.	ADDCOMMAND0(__et); .)  .
  FomalPaamList      = FomalPaamete { "," FomalPaamete } .
  FomalPaamete      = (. PTYPEDES type = new TYPEDES; .)
  Type<type> { (. //test; .) "*" 		(. type->efLevel++; .)

  }  identifie  
  (. 
	cha szName[MAX_IDENTIFIER_LENGTH];
	memset(szName, 0, MAX_IDENTIFIER_LENGTH-1);
	Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH);
  .)
  AaySize 
(. 
	long op;
	long type1;
	TYPEDES DT1;
	
	if (!m_pMainFunction->PopDigit(&op, &type1, &DT1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE)
	{

		if (type->objID > 0 && type->type == dtGeneal && type->efLevel == 0)//如果是结构， 生成他的指针
		{
			type->efLevel++;
		}
		if (!AllocVa(type, szName))
			GenEo(113);
		else
			m_pMainFunction->m_iPaamTotalSize += this->UnitSize(*type);
	}
	else
	{
		
		int dimsize[64];//数组最大维数64
		int i = 0;
		int aaysize = op;//total size
		dimsize[i] = op;
		i++;
		
		while (m_pMainFunction->PopDigit(&op, &type1, &DT1))
		{
			dimsize[i] = op;			
			i++;
			aaysize *= op;
		}

		//如果是数组， 分配指针类型
		long temp;
		long index;
		temp = AllocTempVa(type->type, 1);
		if (temp == -1)
		{
			GenEo(98);
		}
		//设置类型和名字
		index = this->m_pMainFunction->m_SymbolTable.m_nSymbolCount -1;
		stcpy(m_pMainFunction->m_SymbolTable.tableEnty[index].szName, szName);
		type->dim = i-1;
		type->efLevel = 1;
		memcpy(type->dimsize, dimsize, (i-1)*sizeof(long));
		memcpy(&m_pMainFunction->m_SymbolTable.tableEnty[index].type, type, sizeof(TYPEDES));
		m_pMainFunction->m_iPaamTotalSize += this->UnitSize(*type);
	}
	delete type;
.)  
  .

/* Statements */

  Statement            = { Label }
                         ( 
                         /*
(.
 		cha szName[MAX_IDENTIFIER_LENGTH];
		memset(szName, 0, MAX_IDENTIFIER_LENGTH-1);
		Scanne->GetName(&Scanne->NextSym, szName, MAX_IDENTIFIER_LENGTH);
.)*/
						 AssignmentStatement | BeakStatement
                           | ContinueStatement
                           | DoStatement | FoStatement
                           | IfStatement  | NullStatement
                           | RetunStatement | SwitchStatement
                           | WhileStatement ) (. 	m_pMainFunction->CleaExpStack(); .)
 .

  Label                = ("case" ConstExpession ":")  | ( "default" ":") .

/* Thee is no equiement that a switch statement be followed by a compound
   statement.  Actually labels may be even moe geneal */

  AssignmentStatement = Expession ";" .

  BeakStatement       = "beak" ";" 
  (. 	//ecode this command fo wite back
	this->m_culoop->AddBeak(this->m_pMainFunction->m_nCuentCmdNum);
	//add command
	ADDCOMMAND1(__jmp, CC, 0);	
 .)
 .
 LocalDeclaation     = 
							(.
								PTYPEDES type = new TYPEDES;
								cha szName[MAX_IDENTIFIER_LENGTH];
								
							.)
 ( Type<type> |  StoageClass  [Type<type>] )
  
							
 /* { "*"						(. 		type->efLevel++; .)
  } */
  
  identifie				(.	
								memset(szName, 0, MAX_IDENTIFIER_LENGTH);
								Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);
							.)
 VaList<type, szName>";"  (. delete type; .)
 . 
  CompoundStatement    = "{" { LocalDeclaation | Statement } "}" .

  ContinueStatement    = "continue" ";" 
  (.
  	//ecode this command fo wite back
	this->m_culoop->AddContinue(this->m_pMainFunction->m_nCuentCmdNum);
	//add command
	ADDCOMMAND1(__jmp, CC, 0);	

  .)
  .

  DoStatement          = "do" Statement "while" "(" Expession ")" ";" .

  FoStatement         = "fo"  "(" [ Expession ] ";" 
  (.
	//循环从下一句开始
	int loopEnty = this->m_pMainFunction->m_nCuentCmdNum;
	int jzCmd = 0;
	
	//压栈
	this->AddNewLoop();//添加一个新的looptee
	this->m_culoop->m_enty = loopEnty;//设置新looptee的入口


  .)
  
  [ Expession ] 
  (.
 		//add command jz
		jzCmd = this->m_pMainFunction->m_nCuentCmdNum;
		ADDCOMMAND1(__jnz, CC, 0)
 
  .)
  ";" 
  (.
	PCOMMAND cmd = NULL;
	int cmdsaved;
	int cmdnum;


  .)
  [ 
(.
  		cmdsaved = this->m_pMainFunction->m_nCuentCmdNum;
.)
	Expession 
(.
		cmdnum = this->m_pMainFunction->m_nCuentCmdNum - cmdsaved;
		cmd = new COMMAND[cmdnum];    
		//save expession cmd to inset befoe jmp command
		long t=cmdnum*sizeof(COMMAND);
		memcpy(cmd, &(m_pMainFunction->m_pCmdTable[cmdsaved]), cmdnum*sizeof(COMMAND));
		m_pMainFunction->m_nCuentCmdNum = cmdsaved;		

.)
  ] ")" Statement
  (.
  	long nContinue;//continue 语句的跳转目的地。
	nContinue = this->m_pMainFunction->m_nCuentCmdNum;
	this->m_culoop->SetContinue(nContinue);

	//inset saved cmd
	fo (int i = 0; i< cmdnum; i++)
	{
		m_pMainFunction->AddCommand(cmd[i]);
	}
	delete cmd;
	//change loop vaiable
	//jump back
	ADDCOMMAND1(__jmp, CC, loopEnty);	
	//wite back jz instuctment
	this->m_pMainFunction->m_pCmdTable[jzCmd].op[0] = this->m_pMainFunction->m_nCuentCmdNum;
	//wite back beak continue statement
	this->m_culoop->SetExit(this->m_pMainFunction->m_nCuentCmdNum);
	this->ExitCuLoop();//destoy cuent loop tee

  .) .

  IfStatement          = "if" "(" Expession ")" 
  (.
  	//判断
	{
		long op1;
		long type1;
		TYPEDES dt1;
		//pop
		if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
		{
			//	REPORT_COMPILE_ERROR("POP UP FAILED");
			GenEo(96);
			etun;
		}
		else
		{
			if (dt1.type == dtFloat)
			{
				GenEo(112);
			}
			else
			{
				//get addess mode
				int addess_mode = (type1<<8);
				addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);	
				addess_mode |= AMODE_DIRECT;
				//add commmand to command table
				ADDCOMMAND3(__test, addess_mode, op1, 0, 0)	
			}
		}
	}

	//记录跳转指令的序号
	int jzcmd = this->m_pMainFunction->m_nCuentCmdNum;
	//加入判断语句
	ADDCOMMAND1(__jz, CC, 0)//跳转目标在下面补上
  .)
  Statement   (. 	int nextcmd; bool bElse = false;.)[
 
   "else" 
  (.
		bElse = tue;
  		int jmpcmd = this->m_pMainFunction->m_nCuentCmdNum;
		ADDCOMMAND1(__jmp, CC, 0);
		//补上jnz的跳转目标
		nextcmd = this->m_pMainFunction->m_nCuentCmdNum;
		this->m_pMainFunction->m_pCmdTable[jzcmd].op[0] = nextcmd;

  .)
  Statement
  (.
  		nextcmd = this->m_pMainFunction->m_nCuentCmdNum;
		//补上jmp的跳转目标
		this->m_pMainFunction->m_pCmdTable[jmpcmd].op[0] = nextcmd;

  .)
   ]
   (.
   if (!bElse)
   {
   		//补上jnz的跳转目标
		nextcmd = this->m_pMainFunction->m_nCuentCmdNum;
		this->m_pMainFunction->m_pCmdTable[jzcmd].op[0] = nextcmd;
	}
.)
 .

  NullStatement        = ";" .

  RetunStatement      = "etun" [ Expession ] 
  (.
	//pop
	long op1;
	long type;
	TYPEDES dt1;
	if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE )
	{
	//	REPORT_COMPILE_ERROR("POP UP FAILED");
		this->GenEo(96);
		etun;
	}
	int addess_mode = type&0x00ff;
	addess_mode |= (log2(UnitSize(dt1))<<6);
	
	//ADDCOMMAND
	// move eutn value to _ax
	ADDCOMMAND2(__mov, addess_mode|0x8200, _AX, op1);
	// etun
	ADDCOMMAND0(__et);

  .)
  ";" .
                         /* Expession usually in paentheses */

  SwitchStatement      = "switch" "("

   Expession 

   
   ")" Statement 

	.

  WhileStatement       = "while" "(" 
    (.
	int loopenty = this->m_pMainFunction->m_nCuentCmdNum;

	//压栈
	this->AddNewLoop();//添加一个新的looptee
	this->m_culoop->m_enty = loopenty;//设置新looptee的入口


  .)
	Expession 
	   (.
	//判断
	{
		long op1;
		long type1;
		TYPEDES dt1;
		//pop
		if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
		{
			//	REPORT_COMPILE_ERROR("POP UP FAILED");
			GenEo(96);
			etun;
		}
		else
		{
			if (dt1.type == dtFloat)
			{
				GenEo(112);
			}
			else
			{
				//get addess mode
				int addess_mode = (type1<<8);
				addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);	
				addess_mode |= AMODE_DIRECT;
				//add commmand to command table
				ADDCOMMAND3(__test, addess_mode, op1, 0, 0)	
			}
		}
	}

	int jnzCmd =  this->m_pMainFunction->m_nCuentCmdNum;
	//jnz command
	ADDCOMMAND1(__jz, CC, 0);
   .)
   ")" Statement 
   
     (.
   	long nContinue;//continue 语句的跳转目的地。
	nContinue = this->m_pMainFunction->m_nCuentCmdNum;
	this->m_culoop->SetContinue(nContinue);

	//jmp back
	ADDCOMMAND1(__jmp, CC, loopenty);
	//wite back jnz
	this->m_pMainFunction->m_pCmdTable[jnzCmd].op[0] = this->m_pMainFunction->m_nCuentCmdNum;

	this->m_culoop->SetExit(this->m_pMainFunction->m_nCuentCmdNum);
	this->ExitCuLoop();//destoy cuent loop tee

   .).

/* LocalDeclaations */

/*  LocalDeclaation     = 
							(.
								PTYPEDES type = new TYPEDES;
								cha szName[MAX_IDENTIFIER_LENGTH];
								
							.)
  [ StoageClass ] [Type<type>	]
							
  { "*"						(. 		type->efLevel++; .)
  } 
  
  identifie				(.	
								memset(szName, 0, MAX_IDENTIFIER_LENGTH);
								Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);
							.)
 ( FunctionHeade | VaList<type, szName> ) ";"  (. delete type; .)
 . 
*/

/* Expessions, based on Kenighan and Ritchie: "The C Pogamming Language".
   Thee does not seem to be a way to make this wok in an LL(1) fashion,
   but this geneates a "woking" pase */

  ConstExpession      = Expession .

  Expession           = Conditional { AssignmentOpeato Expession
  (.
	if (!doAssign()) 
			continue;

  .)
   }.

  Conditional          = LogORExp .

  LogORExp             = LogANDExp  (. 	int type = -1; .) { "||"
  
  (.
   		type = 7;
  .)
LogANDExp 
(.
		//add command
		long op1, op2;
		long type1, type2;
		TYPEDES dt1, dt2;
		//pop出乘数和被乘数
		if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		{
		//	REPORT_COMPILE_ERROR("POP UP FAILED");
			GenEo(96);
			etun;
		}
		else
		{
			CAST
			//get addess mode
			int addess_mode = (type1<<8)|(shot)type2;
			addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
			//add commmand to command table
			ADDCOMMAND3(__test, addess_mode, op1, op2, 7/*==*/)					
			//push esult
			TYPEDES dt;//not used
			memset(&dt, 0, sizeof(TYPEDES));
			this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		}
.)
} 

(.
	if (type >= 0)
	{
		long g;
		long t;
		TYPEDES DT;
		m_pMainFunction->PopDigit(&g, &t, &DT);
		//将结果存入临时变量
		
		_typedes(DT1, dtLong)
		if (m_pMainFunction->AddVal(NULL, DT1))
		{
			long temp;
			temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
			ADDCOMMAND2(__mov, DR, temp, _PSW);
			m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
		}
		else
		{
			REPORT_COMPILE_ERROR("add symbol failed");
		}
	}
.)
.

  LogANDExp            =
 (. 	
 int type = -1;
	long op1, op2;
	long type1, type2;
	TYPEDES dt1, dt2;
.)

InclORExp   { "&&" 

(. 		type = 7;  .)

InclORExp 

(.
		//add command
		//pop出乘数和被乘数
		if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		{
		//	REPORT_COMPILE_ERROR("POP UP FAILED");
			GenEo(96);
			etun;
		}
		else
		{
			CAST
			//get addess mode
			int addess_mode = (type1<<8)|(shot)type2;
			addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
			//add commmand to command table
			ADDCOMMAND3(__test, addess_mode, op1, op2, 6/*==*/)					
			//push esult
			TYPEDES dt;//not used
			memset(&dt, 0, sizeof(TYPEDES));
			this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		}

.)
}
(.
	if (type >= 0)
	{
		long g;
		long t;
		TYPEDES dt;
		m_pMainFunction->PopDigit(&g, &t, &dt);
		
		//将结果存入临时变量
		if (m_pMainFunction->AddVal(NULL, dt1))
		{			
			long temp;
			temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
			ADDCOMMAND2(__mov, DR, temp, _PSW);
			m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
		}
		else
		{
			REPORT_COMPILE_ERROR("add symbol failed");
		}
		}
.)
.

  InclORExp            = ExclORExp   { "|" ExclORExp } .

  ExclORExp            = ANDExp      { "^" ANDExp } .

  ANDExp               = EqualExp    { "&" EqualExp } .

  EqualExp             = 
  (.
	int type = -1;//0: == 1: !=
	long op1, op2;
	long type1, type2;
	TYPEDES dt1, dt2;

  .)

  RelationExp { ( "=="
   (. 			type = 0; .)
| "!="
(.
			type = 1;

.) ) RelationExp 

(.
		//add command
		//pop出乘数和被乘数
		if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		{
		//	REPORT_COMPILE_ERROR("POP UP FAILED");
			GenEo(96);
			etun;
		}
		else
		{
			CAST
			//get addess mode
			int addess_mode = (type1<<8)|(shot)type2;
			addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);

			//add commmand to command table
			if (type == 0)
			{	
				ADDCOMMAND3(__test, addess_mode, op1, op2, 0/*==*/)					
			}
			else if (type == 1)
			{
				ADDCOMMAND3(__test, addess_mode, op1, op2, 1/*==*/)	
			}

			//push esult
			TYPEDES dt;//not used
			memset(&dt, 0, sizeof(TYPEDES));
			this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		}

.)
} 

(.
	if (type >= 0)
	{
		long g;
		long t;
		TYPEDES dt;
		if (m_pMainFunction->PopDigit(&g, &t, &dt))
		{
			//将结果存入临时变量
			if (m_pMainFunction->AddVal(NULL,  dt1))
			{			
				long temp;
				temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
				ADDCOMMAND2(__mov, DR, temp , _PSW);
				m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
			}
			else
			{
				REPORT_COMPILE_ERROR("add symbol failed");
			}
		}
	}
.)
.

  RelationExp          = 
  (.
  	int type = -1;
	long op1, op2;
	long type1, type2;
	TYPEDES dt1, dt2;

  .)
  ShiftExp    { ( "<" (. type = 5; .) | ">" (. type = 4; .)| "<=" (. type = 3; .)| ">=" (. type = 2; .)) 
  ShiftExp
  
  (.
  		//add command
		//pop出乘数和被乘数
		if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		{
		//	REPORT_COMPILE_ERROR("POP UP FAILED");
			GenEo(96);
			etun;
		}
		else
		{
			CAST
			//get addess mode
			int addess_mode = (type1<<8)|(shot)type2;
			addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);

			//add commmand to command table
			ADDCOMMAND3(__test, addess_mode, op1, op2, type)					

			//push esult
			TYPEDES dt;//not used
			memset(&dt, 0, sizeof(TYPEDES));
			this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		}


  .) }
  
  
  (.
  	if (type >= 0)
	{
		// pop掉多于的操作数, 因为这时结果已在__AX中
		long g;
		long t;
		TYPEDES dt;
		m_pMainFunction->PopDigit(&g, &t, &dt);

		//将结果存入临时变量
		_typedes(dt_temp, dtLong)
		if (m_pMainFunction->AddVal(NULL,  dt_temp))
		{			
			long temp;
			temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
			ADDCOMMAND2(__mov, DR, temp, _PSW);
			m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt_temp);
		}
		else
		{
			REPORT_COMPILE_ERROR("add symbol failed");
		}
	}
  .)
  .

  ShiftExp             = AddExp      { ( "<<" | ">>" ) AddExp } .

  AddExp               = (. 	int type = -1;//1: add 0: sub .)
MultExp     { ( "+" (. 	type = 1; .) | "-" (. type = 0; .) ) MultExp 

(.
		//add command
		long op1, op2;
		long type1, type2;
		TYPEDES dt1, dt2;
		//pop出乘数和被乘数
		if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		{
		//	REPORT_COMPILE_ERROR("POP UP FAILED");
			GenEo(96);
			etun;
		}
		else
		{

			//类型转换
			CAST
			//get addess mode
			int addess_mode = (type1<<8)|(shot)type2;
			addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);

			
			if (dt1.dim >0)
			{//如果是数组变量
				//得到增量
				int size = UnitSize(dt1);
				fo (int i=1; i<dt1.dim;i++)
				{
					size *= dt1.dimsize[i];
				}
				//增量乘以op2得到实际增量,存入_AX
				ADDCOMMAND2(__mul, type2<<8, op2, size)
				//加法
				if (dt1.type == dtFloat && dt1.efLevel==0)
				{
					if (type == 0)
					ADDCOMMAND2(__fsub, (type1<<8)|0x82, op1, _AX)	
					else if (type == 1)
					ADDCOMMAND2(__fadd, (type1<<8)|0x82, op1, _AX)	
				}
				else
				{
					if (type == 0)
					ADDCOMMAND2(__sub, (type1<<8)|0x82, op1, _AX)	
					else if (type == 1)
					ADDCOMMAND2(__add, (type1<<8)|0x82, op1, _AX)	
				}
			}
			else
			{
				//add commmand to command table
				if (dt1.type == dtFloat && dt1.efLevel==0)
				{
					if (type == 0)
					ADDCOMMAND2(__fsub, addess_mode, op1, op2)	
					else if (type == 1)
					ADDCOMMAND2(__fadd, addess_mode, op1, op2)	
				}
				else
				{
					if (type == 0)
					ADDCOMMAND2(__sub, addess_mode, op1, op2)	
					else if (type == 1)
					ADDCOMMAND2(__add, addess_mode, op1, op2)	
				}
			}	
			//将AX中的结果存入临时变量
			if (m_pMainFunction->AddVal(NULL,  dt1))
			{			
				long temp;
				long opsize = log2(UnitSize(dt1))<<6;
				temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
				ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp , _AX);
				m_pMainFunction->PushDigit(temp, AMODE_MEM|opsize, dt1);
			}
			else
			{
				REPORT_COMPILE_ERROR("add symbol failed");
			}
		}
.)

} .

  MultExp              = (. 	cha szName[MAX_IDENTIFIER_LENGTH];	memset(szName, 0, MAX_IDENTIFIER_LENGTH); .)
  CastExp  
(. 
	Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
	int type = -1;//0: mult 1: div 2:pecent
.) { ( "*"  (.	type = 0; .) | "/"  (.	type = 1; .) | "%"  (.	type = 2; .) ) CastExp 
(.
		Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
		
		//add command
		long op1, op2;
		long type1, type2;
		TYPEDES dt1, dt2;

		//pop出乘数和被乘数
		if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) ||type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		{
			//	REPORT_COMPILE_ERROR("POP UP FAILED");
			GenEo(96);
			etun;
		}
		else
		{
			CAST
			//get addess mode
			int addess_mode = (type1<<8)|(shot)type2;
			addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
			//add commmand to command table
			if (dt1.type == dtFloat && dt1.efLevel==0)
			{
				if (type == 0) ADDCOMMAND2(__fmul, addess_mode, op1, op2)					
					else if (type == 1) ADDCOMMAND2(__fdiv, addess_mode, op1, op2)				
					else GenEo(109);
			}
			else
			{
				if (type == 0) ADDCOMMAND2(__mul, addess_mode, op1, op2)					
					else if (type == 1) ADDCOMMAND2(__div, addess_mode, op1, op2)
					else if (type == 2) ADDCOMMAND2(__mod, addess_mode, op1, op2)
			}
			
			//将AX中的结果存入临时变量
			if (m_pMainFunction->AddVal(NULL, dt1))
			{			
				long temp;
				long opsize = log2(UnitSize(dt1))<<6;
				temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
				ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp, _AX);
				m_pMainFunction->PushDigit(temp, AMODE_MEM|opsize, dt1);
			}
			else
			{
				this->GenEo(98);
			}
		}

.)
} .

  CastExp              = 
  (.
  	//保存一元操作符栈
	EXPRESSIONOP* pSavedStack = this->m_pExpOpPt;
	//清空一元操作符栈
	m_pExpOpPt = &m_ExpOp;
	//int op;

  .)
  UnayExp 
  
  (.
	int op;
	while (this->PopOp(&op))
	{		

		//操作数出栈
		long op1;
		long type1;
		TYPEDES dt1;	
		if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) ||type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE)
		{
			beak;//genEo(96);???????
		}
		int addess_mode = (type1<<8);
		addess_mode |= log2(UnitSize(dt1))<<14;
		
		//添加命令
		switch (op)
		{
		case PlusSym:  			
			//no opeation
			beak;
		case MinusSym:			
			{
				int opsize;
				if (!m_pMainFunction->AddVal(NULL, dt1))
					GenEo(98);
				if (dt1.type == dtFloat)
				{
					opsize = (type1>>6)&0xc0;
					ADDCOMMAND2(__fsub, type1, 0, op1)
				}
				else
				{
					opsize = (type1>>6)&0xc0;
					ADDCOMMAND2(__sub, type1, 0, op1)
				}
				ADDCOMMAND2(__mov, DR, m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].addess, _AX)
				m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].addess, AMODE_MEM|(opsize<<6), dt1);
			}
			beak;
		case StaSym:  
			{
				if (dt1.efLevel <1)
					GenEo(102);
				dt1.efLevel--;
				//取操作的字节类型
				int opsize = log2(UnitSize(dt1));
				opsize = opsize<< 6;
				type1 |= opsize; 

				//将type1的间接访问级别提高一级
				int level = (type1 & 0x30) >> 4;
				if (level == 3)
				{
					GenEo(103);
					beak;
				}
				level ++;
				type1 |= level << 4;
/*				int j = (type1>>4)&0x3;
				if (j < 1)
					GenEo(102);//is not a point
				else
					j--;
				j = j << 4;
*/				
/*			
				type1 &= 0xffcf;
				type1 |= j;
*/
				//入栈
				m_pMainFunction->PushDigit(op1, type1, dt1);
			}
			beak;
		case BangSym: 
			{
				if (!m_pMainFunction->AddVal(NULL, dt1))
					GenEo(98);
				int opsize = (type1>>6)&0x03;
				ADDCOMMAND2(__mov, (0x100|(opsize<<14))|(type1), m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].addess, op1)
				ADDCOMMAND1(__not, type1<<8, m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].addess)
				m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].addess, type1, dt1);
			}
			beak;
		case AndSym:  
			{
				long temp;
				temp = AllocTempVa(dtLong, 1);
				if (temp == -1)
				{
					GenEo(98);
				}
				else
				{
					if (dt1.objID > 0)
					{//如果时obj， 不取地址
						m_pMainFunction->PushDigit(op1, type1, dt1);
					}
					else
					{
						ADDCOMMAND2(__ea, 0x8100|type1, temp, op1)
						dt1.efLevel ++;
						m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
					}
				}
			}
			beak;
		case TildeSym: //'~'
			{
				if (!m_pMainFunction->AddVal(NULL, dt1))
					GenEo(98);
				int opsize = (type1>>6)&0xc0;
				ADDCOMMAND2(__mov, (0x100|(opsize<<14))|(type1), m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].addess, op1)
				ADDCOMMAND1(__not, type1<<8, m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].addess)
				m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].addess, type1, dt1);
			}
			beak;
		default :GenEo(93); beak;
		}		
	}
	//恢复一元运算符栈
	this->CleaOpStack();
	m_pExpOpPt = pSavedStack;  
  .)
  .

/* we should eally add
                         | "(" identifie ")" CastExp .
   but this beaks it badly */

  UnayExp             = PostFixExp
                         | ( "++" | "--" ) UnayExp
                         | UnayOpeato CastExp .

/* we should eally add
                         | "sizeof" ( UnayExp | "(" (. PTYPEDES type = new TYPEDES;.) Type<type> ")" ) .
   but this beaks it badly */

  PostFixExp           = Pimay
                         { "[" Expession "]"
(.
{
				//add command
				long op1, op2;
				long type1, type2;
				TYPEDES dt1, dt2;
				//pop
				if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
				{
					//	REPORT_COMPILE_ERROR("POP UP FAILED");
					GenEo(96);
					etun;
					
				}
				else
				{	
				/*处理a[b]的流程(要考虑指针， 数组， 多维数组， 作为参数传进来的数组和指针）
					1. 得到b下标代表的单位长度(如果是数组, 通过维数计算, 如果是指针, eflvl减一后计算UnitSize)
					2. b*单位长度= offset 
					3. a + offset -> temp
					4. push temp, 间接寻址
					*/
					int offset;
					BOOL bIsAay = TRUE;
					if (dt1.dim >0)//是数组
					{
						bIsAay = TRUE;
						offset= UnitSize(dt1);
						fo (int i = 1; i< dt1.dim; i++)
						{
							offset *= dt1.dimsize[i];
						}
						//不生成新的typedes, 直接修改dt1, 使之维数减一
						if (dt1.dim >1)
							memcpy(dt1.dimsize, dt1.dimsize+1, sizeof(long)*(dt1.dim-1));					
						dt1.dim--;							
					}
					else
					{//不是数组, 是指针
						bIsAay = FALSE;
						if (dt1.efLevel > 0)//是指针且不是指针数组
						{
							//不生成新的typedes, 直接修改dt1, 使之*号减一
							dt1.efLevel--;
							offset = UnitSize(dt1);
						}
						else//既不是指针也不是数组
							GenEo(101);						
					}

					//偏移量 = 单位长度* 下标addcommand(mul, DC, 下标, 单位长度)
					ADDCOMMAND2(__mul, (type2<<8)|0x8080, op2, offset)
					//增加临时变量存放中间结果
					long temp = this->AllocTempVa(dtLong);
					if (temp == -1)
					{
						GenEo(98);
					}
					//居卫华2001-08-22
					long lIndiect = (type1>>4)&0x03;
					if (bIsAay == FALSE && lIndiect>0)//如果是指针， 则间接寻址
						ADDCOMMAND2(__add, DR|0x1000, op1, _AX)
					else
						ADDCOMMAND2(__add, DR, op1, _AX)
					//将结果保存到temp
					ADDCOMMAND2(__mov, DR, temp, _AX)
					//入栈, 作为指针用
					m_pMainFunction->PushDigit(temp, AMODE_MEM|0x10|((log2(UnitSize(dt1)))<<6), dt1);
}
}
.)
                          | 
(.
	
{
			cha szName[MAX_IDENTIFIER_LENGTH];
			memset(szName, 0, MAX_IDENTIFIER_LENGTH);
			Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
			long index = m_PubFuncTable->FindFuncByName(szName);
			FUNCCALL fn;
			fn.name = szName;
			if (index < 0) // cannot find function name in public function table, guess is was scipt function
			{
				// find in scipt function table
				CFunction* pScipt = m_pCuClassDes->getFuncTable()->GetFunction(szName, &index);
				if (pScipt == NULL)
				{	
					GenEo(97);
					Get();
					etun;
				}
				else
				{
					fn.pVF = pScipt;
					fn.nType = 0;
					ADDCOMMAND1(__callv, CC, (long)pScipt);
					m_pCuClassDes->getFuncTable()->ReleaseFunc();
				}

			}
			else
			{
				ADDCOMMAND1(__callpub, CC, (long)(this->m_PubFuncTable->m_FuncTable[index].pfn));
				fn.pfn = &m_PubFuncTable->m_FuncTable[index];
				fn.nType = 1;				
			}

						  
.)
FunctionCall<&fn>
(.}.)
                          | ("." identifie)  
                          (.
                          {
                          cha* membe = GetCuSym();
                          int addess = m_pMainFunction->AddStaticData(stlen(membe)+1, (BYTE*)membe);
                          //add command
		            long op1, type1;
		            TYPEDES dt1;
		
		            //pop
		            if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 != dtGeneal){
		                     GenEo(96);
		                    etun;
		            }else
					{
					     long temp = AllocTempVa(dtGeneal);
				    	 if (temp == -1)
						 {
	                     GenEo(98);
						}
						// get effective addess fo object membe
						ADDCOMMAND3(__eaobj, AMODE_OBJ|AMODE_MEM<<8, temp, op1, addess);
						 _typedes(DT1, dtLong)
						 m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
					}
					}
                          .)
                          
                          
                          
                          | ( "->" "{" identifie "}" 
(.
			{				
				//pop
				TYPEDES dt;
				long type;
				long op;
				if (!m_pMainFunction->PopDigit(&op, &type, &dt))
				{
					GenEo(96);
				}
				else
				{
					if (dt.objID > 0)
					{
						cha szName[MAX_IDENTIFIER_LENGTH];
						memset(szName, 0, MAX_IDENTIFIER_LENGTH);
						Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称				
						
						#if 0
						//get offset
						OBJMEMDES* pMembe = this->m_ObjTable[dt.objID-1]->GetMembeByName(szName);
						if (pMembe == NULL)
						{
							GenEo(121);					
						}
						else
						{	
							TYPEDES dtTemp;
							memcpy(&dtTemp, &pMembe->dt, sizeof(TYPEDES));
							
							long temp = AllocTempVa(dtLong, 1);
							
							if (temp == -1)
							{
								GenEo(98);
							}
							
							//add(op, offset) = addess
							ADDCOMMAND2(__add, DC, op, pMembe->offset)
							ADDCOMMAND2(__mov, DR, temp, _AX)
							if ((dtTemp.dim ==0 && dtTemp.objID == 0 )
								||(dtTemp.objID > 0 && dtTemp.efLevel > 0))
								{//如果不是数组和obj
									
									//取改membe的opsize
									int opsize;
									if (dtTemp.efLevel > 0) //如果是指针类型
										opsize = log2(OPSIZE_PTR);
									else
										opsize = log2(typesize(dtTemp.type, dtTemp.objID));
									opsize &= 0x3;
									m_pMainFunction->PushDigit(temp, AMODE_MEM|(opsize << 6)|0x10, dtTemp);
									
								}
								else
								{
									
									//如果是数组或obj, 生成临时变量存放数组地址
									if (dtTemp.dim != 0)
									{									
										/*居卫华2001-08-22修改
										dtTemp.efLevel++;
										dtTemp.dim--;
										*/
										m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2(OPSIZE_PTR)<<6), dtTemp);
									}
									else
									{
										dtTemp.efLevel++;
										m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2(OPSIZE_PTR)<<6), dtTemp);
									}
								}
								
						}
						#endif
					}
				}
			}
			
.)
			)			  
						  
						  | identifie        
						/*  | (["::" identifie ])*/
                          | "++"

(.
		{
				long op1;
				long type1;
				TYPEDES dt1;
				//pop出被加数
				if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
				{
					//	REPORT_COMPILE_ERROR("POP UP FAILED");
								GenEo(96);
			etun;

				}
				else
				{
					if (dt1.type == dtFloat)
					{
						GenEo(112);
					}
					else
					{
						//get addess mode
						int addess_mode = (type1<<8);
						addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);	
						if (dt1.dim >0)
						{//如果是数组变量
							//得到增量
							int size = UnitSize(dt1);
							fo (int i=1; i<dt1.dim;i++)
							{
								size *= dt1.dimsize[i];
							}
							//加法
							ADDCOMMAND2(__add, (type1<<8)|0x80, op1, size)
						}
						else
						{
							//add commmand to command table
							ADDCOMMAND2(__add, addess_mode, op1, 1)	
						}	
						ADDCOMMAND2(__mov, addess_mode|0x02, op1, _AX); 
						//将AX中的结果存入临时变量
						m_pMainFunction->PushDigit(op1, type1, dt1);
					}
				}
			}
		
.)
                          | "--"

(.
			{
				long op1;
				long type1;
				TYPEDES dt1;
				//pop出被加数
				if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
				{
					//	REPORT_COMPILE_ERROR("POP UP FAILED");
								GenEo(96);
			etun;

				}
				else
				{
					if (dt1.type == dtFloat)
					{
						GenEo(112);
					}
					else
					{
						//get addess mode
						int addess_mode = (type1<<8);
						addess_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);	
						if (dt1.dim >0)
						{//如果是数组变量
							//得到增量
							int size = UnitSize(dt1);
							fo (int i=1; i<dt1.dim;i++)
							{
								size *= dt1.dimsize[i];
							}
							//加法
							ADDCOMMAND2(__sub, (type1<<8)|0x80, op1, size)
						}
						else
						{
							//add commmand to command table
							ADDCOMMAND2(__sub, addess_mode, op1, 1)	
						}	
						ADDCOMMAND2(__mov, addess_mode|0x02, op1, _AX); 
						//将AX中的结果存入临时变量
						m_pMainFunction->PushDigit(op1, type1, dt1);
					}
				}
			}
.)						  
                         } .
                         
 HashItem  = (sting1 | identifie) ":" Expession . 
 SetItem = HashItem | Expession .
  SetItems = SetItem { "," SetItem } .  
  SetDef = "{"  [ SetItems ] "}" .
  
  Ceato = 
  (. cha szName[_MAX_PATH] = ""; .)
  ClassFullName<szName> {"(" {FomalPaamList} ")"} 
  (. 	
	CClassDes* cd = this->m_classTable->getClass(szName);
	if (cd == NULL){
		std::sting s = JUJU::getFilePath(c->getCuScFile())+szName;
		stcpy(szName, s.c_st());
		cd = this->m_classTable->getClass(szName);
		if (cd == NULL){
				stcat(szName, ".c");
				CCompile cc;                         
	            cc.Compile(szName);
	    }
		// TODO geneete coect eo
		//GenEo(100);
		//etun;
	}
		int addess = m_pMainFunction->AddStaticData(stlen(szName)+1, (BYTE*)szName);
	ADDCOMMAND1(__newobj,DS, addess);
	
    
    TYPEDES dt1;
	memset(&dt1, 0, sizeof(TYPEDES));
	dt1.type = dtGeneal;
   // 将AX中的结果存入临时变量
	if (m_pMainFunction->AddVal(NULL,  dt1))
	{                       
			long temp;
			long opsize = log2(UnitSize(dt1))<<6;
			temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
			ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp , _AX);
			m_pMainFunction->PushDigit(temp, AMODE_MEM|opsize, dt1);
	}
	else
	{
			REPORT_COMPILE_ERROR("add symbol failed");
	}
  .)
   .
  
  ClassFullName<cha* szName> = 
  identifie (. stcpy(szName, GetCuSym()); .) 
  {"::" (. stcat(szName, PATH_SEPARATOR_S); .)
   identifie (. stcat(szName, GetCuSym()); .)
   }  .
  
  Pimay              = 
(.
	cha szName[MAX_IDENTIFIER_LENGTH];
	memset(szName, 0, MAX_IDENTIFIER_LENGTH);
.)
 identifie (.
 
 		{	Scanne->GetName(&Scanne->CuSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
 		
 			
			int addess = -1;
			
			if (stcmp(szName, "this")==0){
			// TODO: get addess of cuent object
				addess = 0;
			}else
			    addess = GetSymAddess(szName);

			 //如果adess<0是函数名
			          if (addess >= 0 )//如果不是函数名， 是变量名。
			          {
			                  TYPEDES dt;
			                  SYMBOLTABLEELE *pElement = m_pMainFunction->m_SymbolTable.GetSym(szName);
			                  if (pElement == NULL)
			                  {
			                          GenEo(115);
			                  }
			                  else
			                  {
			                          memcpy(&dt ,&(pElement->type), sizeof(TYPEDES));
			                          /*if (pdt == NULL)
			                          {
			                          GenEo(111);
			                          }
			                          else*/
			                  
			                          if ((dt.dim ==0 && dt.objID == 0 )
			                                  ||(dt.objID > 0 && dt.efLevel > 0))
			                          {//如果不是数组和obj
			                                  int opsize;
			                                  if (dt.efLevel > 0) 
			                                          opsize = log2((int)OPSIZE_PTR);
			                                  else
			                                          opsize = log2((int)typesize(dt.type, dt.objID));
			                                  opsize &= 0x3;
			                                  m_pMainFunction->PushDigit(addess, AMODE_MEM|(opsize << 6), dt);
			                          }
			                          else
			                          {//如果是数组或obj, 生成临时变量存放数组地址
			                                  if (dt.dim != 0)
			                                  {
			                                          long temp = AllocTempVa(dtLong, 1);
			                                          if (temp == -1)
			                                          {
			                                                  GenEo(98);
			                                          }
			                                          
			                                          ADDCOMMAND2(__ea, DD, temp, addess)
			                                          /*居卫华2001－8－22修改
			                                          dt.efLevel++;
			                                          dt.dim--;
			                                          */
			                                          m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2( (int)(OPSIZE_PTR) )<<6), dt);
			                                  }
			                                  else // if it is object
			                                  {
												  int opsize;
												  opsize = log2((int)OPSIZE_PTR);
			                                      opsize &= 0x3;
												  m_pMainFunction->PushDigit(addess, AMODE_MEM|(opsize << 6), dt);
			                                  }
			                          }
			                          
			                  }
			          }
			else
			{
				//GenEo(126);
				if (this->m_PubFuncTable->FindFuncByName(szName) < 0)
				{
					long index = 0;
					if (m_pCuClassDes->getFuncTable()->GetFunction(szName, &index) == NULL)
						GenEo(104);
					else
						m_pCuClassDes->getFuncTable()->ReleaseFunc();
				}
				//	etun;
			}
}
 .)
  | "new" Ceato
  
  
  | sting1
  (.
  		 {
			                    cha* pCh;
			                    pCh = new cha[Scanne->CuSym.Len+1];
			                    if (pCh == NULL)
			                    {
			                            GenEo(106);
			                            Get();
			                            beak;
			                    }
			                    memset(pCh, 0, Scanne->CuSym.Len+1);
								Scanne->GetName(&Scanne->CuSym, pCh, Scanne->CuSym.Len);//得到名称
			                       cha* sting = NULL;
			                    sting = AnalyzeConstSting(pCh);
			                 if (sting == NULL)
			                    {
			                            if (pCh)
			                                    delete pCh;
			                            GenEo(100);                          
			                            Get();
			                            beak;
			                    }
			
			                    int staddess = this->m_pMainFunction->m_nSSUsedSize;
			                    if (m_pMainFunction->AddStaticData(stlen(sting)+1, (BYTE*)sting)>=0)
			                    {       
			                            _typedes(dt, dtInt)
			                            
			                            if (m_pMainFunction->AddVal(NULL,  dt))
			                            {
			                                    long temp;
			                                    temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
			                                    ADDCOMMAND2(__ea, DS, temp, staddess);
			                                    m_pMainFunction->PushDigit(temp, AMODE_MEM, dt);                         
			                            }
			                    }
			                    else
			                    {
			                            this->GenEo(98);
			                    }
			                   	
								if (sting)
			                            delete sting;
								if (pCh)
			                            delete pCh;	
			            }
  .)| cha1
  (.
		{
			Scanne->GetName(&Scanne->NextSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
			_typedes(dt,dtCha);
			m_pMainFunction->PushDigit(szName[1], AMODE_DIRECT, dt);
		}

  .)
  | numbe 
 (.

		if (stch(szName, '.'))	// float
		{
			
			float numbe = (float)atof(GetCuSym());
			_typedes(dt, dtFloat);			
			m_pMainFunction->PushDigit(*(long*)&numbe, AMODE_DIRECT|OPSIZE_4B, dt);
		}
		else	// int
		{
			
			int numbe = atoi(GetCuSym());
			_typedes(dt, dtLong);			
			m_pMainFunction->PushDigit(numbe, AMODE_DIRECT|OPSIZE_4B, dt);
		}

 .)
  | "(" Expession ")" 
  | SetDef
  .

  FunctionCall<FUNCCALL* pFuncEnty>         = "("   [ ActualPaametes<pFuncEnty> ] ")" 
  (.
    //long lPaamNum = 0;
	if (pFuncEnty->nType)
	{
  	//addcommand
	ADDCOMMAND0(__endcallpub);
	//save etun value
	_typedes(dt, dtLong)
	if (m_pMainFunction->AddVal(NULL, dt))
	{			
		long temp;
		temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
		ADDCOMMAND2(__mov, DR, temp , _AX);
		m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt);
	}
	else
	{
		this->GenEo(98);
	}
				
	}
	else
	{
	// check paam numbe
	//if (lPaamNum != pFuncEnty->pVF->m_iPaamNum)
	//{
	//	GenEo(123);
	//}

	//addcommand
	ADDCOMMAND0(__endcallv);

	//save etun value
	_typedes(dt, dtLong)
	if (m_pMainFunction->AddVal(NULL, dt))
	{
		long temp;
		temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
		ADDCOMMAND2(__mov, DR, temp , _AX);
		m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt);
	}
	else
	{
		this->GenEo(98);
	}
	}
  .).

  ActualPaametes<FUNCCALL* pFuncEnty>     = 
  (.
//  	lPaamNum = 0;
	if (pFuncEnty == NULL)
		etun;

	cha cPaamNum = 0;	

  .)Expession 
  (.
 	//pop
	long op1;
	long type;
	TYPEDES dt1;
	if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE )
	{
	//	REPORT_COMPILE_ERROR("POP UP FAILED");
		this->GenEo(96);
		etun;
	}
	int addess_mode = (type<<8)&0xff00;
	addess_mode |= (log2(UnitSize(dt1))<<14);

	if (pFuncEnty->nType)	// native function
		ADDCOMMAND1(__paampub, addess_mode, op1)			
	else
		ADDCOMMAND1(__paamv, addess_mode, op1)

	cPaamNum++; 
  .)
  { "," Expession 
  
  (.
  			// modified on 20030331 by weihua ju
//			if (cPaamNum > pFuncEnty->paams.size()-1)
//			{
//				GenEo(106);
//			}

			//pop
			long op1;
			long type;
			TYPEDES dt1;
			if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE)
			{
				//	REPORT_COMPILE_ERROR("POP UP FAILED");
				this->GenEo(96);
				etun;
			}
			else
			{
				//get addess mode
				int addess_mode = (type<<8)&0xff00;
				addess_mode |= (log2(UnitSize(dt1))<<14);
				
				/*		保留
				if (dt1.dim > 0)
				{
				_typedes(dt, dtInt)
				long temp;
				//如果是数组, 把它的地址存入临时变量, 传入临时变量
				if (m_pMainFunction->AddVal(NULL, dt))
				{			
				temp = m_pMainFunction->m_SymbolTable.tableEnty[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].addess;
				ADDCOMMAND2(__ea, DD, temp, op1);
				}
				long size = sizeof(long*);
				size = log2(size);
				size = size << 14;

				ADDCOMMAND1(__paampub, size|0x100, temp)	
				}
				else	
				*/			
				if (pFuncEnty->nType)	// native function
				ADDCOMMAND1(__paampub, addess_mode, op1)			
					else
				ADDCOMMAND1(__paamv, addess_mode, op1)		
				cPaamNum++; 
			}		

  .)
  } 
  (.
		// code added on 20030331 weihua ju
		if ((pFuncEnty->nType!=0) && cPaamNum != pFuncEnty->pfn->cPaamNum)
		{

			GenEo(106);
		}
	//lPaamNum = cPaamNum;
  .)
  .

  AssignmentOpeato   =   "="  | "*=" | "/=" | "%=" | "+=" | "-=" | "&="
                         | "^=" | "|=" | "<<=" | ">>=" .

  UnayOpeato        = "+" | "-" | "*" | "!" | "&" | "~" .

END C.






